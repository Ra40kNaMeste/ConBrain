{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import {\n  assignmentExpression,\n  expressionStatement,\n  identifier,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type { NodePath, Visitor } from \"@babel/traverse\";\n\nexport type EmitFunction = (\n  id: t.Identifier,\n  idName: string,\n  hasInit: boolean,\n) => any;\n\ntype State = {\n  kind: \"var\" | \"let\";\n  emit: EmitFunction;\n};\n\ntype Unpacked<T> = T extends (infer U)[] ? U : T;\n\nconst visitor: Visitor<State> = {\n  Scope(path, state) {\n    if (state.kind === \"let\") path.skip();\n  },\n\n  FunctionParent(path) {\n    path.skip();\n  },\n\n  VariableDeclaration(path, state) {\n    if (state.kind && path.node.kind !== state.kind) return;\n\n    const nodes = [];\n\n    const declarations: ReadonlyArray<\n      NodePath<Unpacked<t.VariableDeclaration[\"declarations\"]>>\n    > = path.get(\"declarations\");\n    let firstId;\n\n    for (const declar of declarations) {\n      firstId = declar.node.id;\n\n      if (declar.node.init) {\n        nodes.push(\n          expressionStatement(\n            assignmentExpression(\"=\", declar.node.id, declar.node.init),\n          ),\n        );\n      }\n\n      for (const name of Object.keys(declar.getBindingIdentifiers())) {\n        state.emit(identifier(name), name, declar.node.init !== null);\n      }\n    }\n\n    // for (var i in test)\n    if (path.parentPath.isFor({ left: path.node })) {\n      path.replaceWith(firstId);\n    } else {\n      path.replaceWithMultiple(nodes);\n    }\n  },\n};\n\nexport default function hoistVariables(\n  path: NodePath,\n  emit: EmitFunction,\n  kind: \"var\" | \"let\" = \"var\",\n) {\n  path.traverse(visitor, { kind, emit });\n}\n"],"names":["assignmentExpression","expressionStatement","identifier","_t","visitor","Scope","path","state","kind","skip","FunctionParent","VariableDeclaration","node","nodes","declarations","get","firstId","declar","id","init","push","name","Object","keys","getBindingIdentifiers","emit","parentPath","isFor","left","replaceWith","replaceWithMultiple","hoistVariables","traverse"],"mappings":";;AAIsB,MAAA;EAHpBA,oBAAoB;EACpBC,mBAAmB;AACnBC,EAAAA,UAAAA;AAAU,CAAA,GAAAC,EAAA,CAAA;AAkBZ,MAAMC,OAAuB,GAAG;AAC9BC,EAAAA,KAAKA,CAACC,IAAI,EAAEC,KAAK,EAAE;IACjB,IAAIA,KAAK,CAACC,IAAI,KAAK,KAAK,EAAEF,IAAI,CAACG,IAAI,EAAE,CAAA;GACtC;EAEDC,cAAcA,CAACJ,IAAI,EAAE;IACnBA,IAAI,CAACG,IAAI,EAAE,CAAA;GACZ;AAEDE,EAAAA,mBAAmBA,CAACL,IAAI,EAAEC,KAAK,EAAE;AAC/B,IAAA,IAAIA,KAAK,CAACC,IAAI,IAAIF,IAAI,CAACM,IAAI,CAACJ,IAAI,KAAKD,KAAK,CAACC,IAAI,EAAE,OAAA;IAEjD,MAAMK,KAAK,GAAG,EAAE,CAAA;AAEhB,IAAA,MAAMC,YAEL,GAAGR,IAAI,CAACS,GAAG,CAAC,cAAc,CAAC,CAAA;AAC5B,IAAA,IAAIC,OAAO,CAAA;AAEX,IAAA,KAAK,MAAMC,MAAM,IAAIH,YAAY,EAAE;AACjCE,MAAAA,OAAO,GAAGC,MAAM,CAACL,IAAI,CAACM,EAAE,CAAA;AAExB,MAAA,IAAID,MAAM,CAACL,IAAI,CAACO,IAAI,EAAE;QACpBN,KAAK,CAACO,IAAI,CACRnB,mBAAmB,CACjBD,oBAAoB,CAAC,GAAG,EAAEiB,MAAM,CAACL,IAAI,CAACM,EAAE,EAAED,MAAM,CAACL,IAAI,CAACO,IAAI,CAC5D,CACF,CAAC,CAAA;AACH,OAAA;AAEA,MAAA,KAAK,MAAME,IAAI,IAAIC,MAAM,CAACC,IAAI,CAACN,MAAM,CAACO,qBAAqB,EAAE,CAAC,EAAE;AAC9DjB,QAAAA,KAAK,CAACkB,IAAI,CAACvB,UAAU,CAACmB,IAAI,CAAC,EAAEA,IAAI,EAAEJ,MAAM,CAACL,IAAI,CAACO,IAAI,KAAK,IAAI,CAAC,CAAA;AAC/D,OAAA;AACF,KAAA;AAGA,IAAA,IAAIb,IAAI,CAACoB,UAAU,CAACC,KAAK,CAAC;MAAEC,IAAI,EAAEtB,IAAI,CAACM,IAAAA;AAAK,KAAC,CAAC,EAAE;AAC9CN,MAAAA,IAAI,CAACuB,WAAW,CAACb,OAAO,CAAC,CAAA;AAC3B,KAAC,MAAM;AACLV,MAAAA,IAAI,CAACwB,mBAAmB,CAACjB,KAAK,CAAC,CAAA;AACjC,KAAA;AACF,GAAA;AACF,CAAC,CAAA;AAEc,SAASkB,cAAcA,CACpCzB,IAAc,EACdmB,IAAkB,EAClBjB,IAAmB,GAAG,KAAK,EAC3B;AACAF,EAAAA,IAAI,CAAC0B,QAAQ,CAAC5B,OAAO,EAAE;IAAEI,IAAI;AAAEiB,IAAAA,IAAAA;AAAK,GAAC,CAAC,CAAA;AACxC;;;;"}