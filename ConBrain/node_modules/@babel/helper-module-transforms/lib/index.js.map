{"version":3,"file":"index.js","sources":["../src/rewrite-this.ts","../src/rewrite-live-references.ts","../src/normalize-and-load-metadata.ts","../src/lazy-modules.ts","../src/dynamic-import.ts","../src/get-module-name.ts","../src/index.ts"],"sourcesContent":["import environmentVisitor from \"@babel/helper-environment-visitor\";\nimport { traverse, types as t } from \"@babel/core\";\nconst { numericLiteral, unaryExpression } = t;\n\nimport type { NodePath, Visitor } from \"@babel/traverse\";\n\n/**\n * A visitor to walk the tree, rewriting all `this` references in the top-level scope to be\n * `void 0` (undefined).\n */\nconst rewriteThisVisitor: Visitor = traverse.visitors.merge([\n  environmentVisitor,\n  {\n    ThisExpression(path) {\n      path.replaceWith(unaryExpression(\"void\", numericLiteral(0), true));\n    },\n  },\n]);\n\nexport default function rewriteThis(programPath: NodePath) {\n  // Rewrite \"this\" to be \"undefined\".\n  traverse(programPath.node, { ...rewriteThisVisitor, noScope: true });\n}\n","import assert from \"assert\";\nimport { template, types as t } from \"@babel/core\";\nimport type { NodePath, Visitor, Scope } from \"@babel/traverse\";\nimport simplifyAccess from \"@babel/helper-simple-access\";\n\nimport type { ModuleMetadata } from \"./normalize-and-load-metadata.ts\";\n\nconst {\n  assignmentExpression,\n  cloneNode,\n  expressionStatement,\n  getOuterBindingIdentifiers,\n  identifier,\n  isArrowFunctionExpression,\n  isClassExpression,\n  isFunctionExpression,\n  isIdentifier,\n  isMemberExpression,\n  isVariableDeclaration,\n  jsxIdentifier,\n  jsxMemberExpression,\n  memberExpression,\n  numericLiteral,\n  sequenceExpression,\n  stringLiteral,\n  variableDeclaration,\n  variableDeclarator,\n} = t;\n\ninterface RewriteReferencesVisitorState {\n  exported: Map<any, any>;\n  metadata: ModuleMetadata;\n  requeueInParent: (path: NodePath) => void;\n  scope: Scope;\n  imported: Map<any, any>;\n  buildImportReference: (\n    [source, importName, localName]: readonly [string, string, string],\n    identNode: t.Identifier | t.CallExpression | t.JSXIdentifier,\n  ) => any;\n  seen: WeakSet<object>;\n}\n\ninterface RewriteBindingInitVisitorState {\n  exported: Map<any, any>;\n  metadata: ModuleMetadata;\n  requeueInParent: (path: NodePath) => void;\n  scope: Scope;\n}\n\nfunction isInType(path: NodePath) {\n  do {\n    switch (path.parent.type) {\n      case \"TSTypeAnnotation\":\n      case \"TSTypeAliasDeclaration\":\n      case \"TSTypeReference\":\n      case \"TypeAnnotation\":\n      case \"TypeAlias\":\n        return true;\n      case \"ExportSpecifier\":\n        return (\n          (\n            path.parentPath.parent as\n              | t.ExportDefaultDeclaration\n              | t.ExportNamedDeclaration\n          ).exportKind === \"type\"\n        );\n      default:\n        if (path.parentPath.isStatement() || path.parentPath.isExpression()) {\n          return false;\n        }\n    }\n  } while ((path = path.parentPath));\n}\n\nexport default function rewriteLiveReferences(\n  programPath: NodePath<t.Program>,\n  metadata: ModuleMetadata,\n  wrapReference: (ref: t.Expression, payload: unknown) => null | t.Expression,\n) {\n  const imported = new Map();\n  const exported = new Map();\n  const requeueInParent = (path: NodePath) => {\n    // Manually re-queue `exports.default =` expressions so that the ES3\n    // transform has an opportunity to convert them. Ideally this would\n    // happen automatically from the replaceWith above. See #4140 for\n    // more info.\n    programPath.requeue(path);\n  };\n\n  for (const [source, data] of metadata.source) {\n    for (const [localName, importName] of data.imports) {\n      imported.set(localName, [source, importName, null]);\n    }\n    for (const localName of data.importsNamespace) {\n      imported.set(localName, [source, null, localName]);\n    }\n  }\n\n  for (const [local, data] of metadata.local) {\n    let exportMeta = exported.get(local);\n    if (!exportMeta) {\n      exportMeta = [];\n      exported.set(local, exportMeta);\n    }\n\n    exportMeta.push(...data.names);\n  }\n\n  // Rewrite initialization of bindings to update exports.\n  const rewriteBindingInitVisitorState: RewriteBindingInitVisitorState = {\n    metadata,\n    requeueInParent,\n    scope: programPath.scope,\n    exported, // local name => exported name list\n  };\n  programPath.traverse(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    rewriteBindingInitVisitor,\n    rewriteBindingInitVisitorState,\n  );\n\n  // NOTE(logan): The 'Array.from' calls are to make this code with in loose mode.\n  const bindingNames = new Set([\n    ...Array.from(imported.keys()),\n    ...Array.from(exported.keys()),\n  ]);\n  if (process.env.BABEL_8_BREAKING) {\n    simplifyAccess(programPath, bindingNames);\n  } else {\n    // @ts-ignore(Babel 7 vs Babel 8) The third param has been removed in Babel 8.\n    simplifyAccess(programPath, bindingNames, false);\n  }\n\n  // Rewrite reads/writes from imports and exports to have the correct behavior.\n  const rewriteReferencesVisitorState: RewriteReferencesVisitorState = {\n    seen: new WeakSet(),\n    metadata,\n    requeueInParent,\n    scope: programPath.scope,\n    imported, // local / import\n    exported, // local name => exported name list\n    buildImportReference([source, importName, localName], identNode) {\n      const meta = metadata.source.get(source);\n      meta.referenced = true;\n\n      if (localName) {\n        if (meta.wrap) {\n          // @ts-expect-error Fixme: we should handle the case when identNode is a JSXIdentifier\n          identNode = wrapReference(identNode, meta.wrap) ?? identNode;\n        }\n        return identNode;\n      }\n\n      let namespace: t.Expression = identifier(meta.name);\n      if (meta.wrap) {\n        namespace = wrapReference(namespace, meta.wrap) ?? namespace;\n      }\n\n      if (importName === \"default\" && meta.interop === \"node-default\") {\n        return namespace;\n      }\n\n      const computed = metadata.stringSpecifiers.has(importName);\n\n      return memberExpression(\n        namespace,\n        computed ? stringLiteral(importName) : identifier(importName),\n        computed,\n      );\n    },\n  };\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  programPath.traverse(rewriteReferencesVisitor, rewriteReferencesVisitorState);\n}\n\n/**\n * A visitor to inject export update statements during binding initialization.\n */\nconst rewriteBindingInitVisitor: Visitor<RewriteBindingInitVisitorState> = {\n  Scope(path) {\n    path.skip();\n  },\n  ClassDeclaration(path) {\n    const { requeueInParent, exported, metadata } = this;\n\n    const { id } = path.node;\n    if (!id) throw new Error(\"Expected class to have a name\");\n    const localName = id.name;\n\n    const exportNames = exported.get(localName) || [];\n    if (exportNames.length > 0) {\n      const statement = expressionStatement(\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        buildBindingExportAssignmentExpression(\n          metadata,\n          exportNames,\n          identifier(localName),\n          path.scope,\n        ),\n      );\n      // @ts-expect-error todo(flow->ts): avoid mutations\n      statement._blockHoist = path.node._blockHoist;\n\n      requeueInParent(path.insertAfter(statement)[0]);\n    }\n  },\n  VariableDeclaration(path) {\n    const { requeueInParent, exported, metadata } = this;\n\n    const isVar = path.node.kind === \"var\";\n\n    for (const decl of path.get(\"declarations\")) {\n      const { id } = decl.node;\n      let { init } = decl.node;\n      if (\n        isIdentifier(id) &&\n        exported.has(id.name) &&\n        !isArrowFunctionExpression(init) &&\n        (!isFunctionExpression(init) || init.id) &&\n        (!isClassExpression(init) || init.id)\n      ) {\n        if (!init) {\n          if (isVar) {\n            // This variable might have already been assigned to, and the\n            // uninitalized declaration doesn't set it to `undefined` and does\n            // not updated the exported value.\n            continue;\n          } else {\n            init = path.scope.buildUndefinedNode();\n          }\n        }\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        decl.node.init = buildBindingExportAssignmentExpression(\n          metadata,\n          exported.get(id.name),\n          init,\n          path.scope,\n        );\n        requeueInParent(decl.get(\"init\"));\n      } else {\n        for (const localName of Object.keys(\n          decl.getOuterBindingIdentifiers(),\n        )) {\n          if (exported.has(localName)) {\n            const statement = expressionStatement(\n              // eslint-disable-next-line @typescript-eslint/no-use-before-define\n              buildBindingExportAssignmentExpression(\n                metadata,\n                exported.get(localName),\n                identifier(localName),\n                path.scope,\n              ),\n            );\n            // @ts-expect-error todo(flow->ts): avoid mutations\n            statement._blockHoist = path.node._blockHoist;\n\n            requeueInParent(path.insertAfter(statement)[0]);\n          }\n        }\n      }\n    }\n  },\n};\n\nconst buildBindingExportAssignmentExpression = (\n  metadata: ModuleMetadata,\n  exportNames: string[],\n  localExpr: t.Expression,\n  scope: Scope,\n) => {\n  const exportsObjectName = metadata.exportName;\n  for (\n    let currentScope = scope;\n    currentScope != null;\n    currentScope = currentScope.parent\n  ) {\n    if (currentScope.hasOwnBinding(exportsObjectName)) {\n      currentScope.rename(exportsObjectName);\n    }\n  }\n  return (exportNames || []).reduce((expr, exportName) => {\n    // class Foo {} export { Foo, Foo as Bar };\n    // as\n    // class Foo {} exports.Foo = exports.Bar = Foo;\n    const { stringSpecifiers } = metadata;\n    const computed = stringSpecifiers.has(exportName);\n    return assignmentExpression(\n      \"=\",\n      memberExpression(\n        identifier(exportsObjectName),\n        computed ? stringLiteral(exportName) : identifier(exportName),\n        /* computed */ computed,\n      ),\n      expr,\n    );\n  }, localExpr);\n};\n\nconst buildImportThrow = (localName: string) => {\n  return template.expression.ast`\n    (function() {\n      throw new Error('\"' + '${localName}' + '\" is read-only.');\n    })()\n  `;\n};\n\nconst rewriteReferencesVisitor: Visitor<RewriteReferencesVisitorState> = {\n  ReferencedIdentifier(path) {\n    const { seen, buildImportReference, scope, imported, requeueInParent } =\n      this;\n    if (seen.has(path.node)) return;\n    seen.add(path.node);\n\n    const localName = path.node.name;\n\n    const importData = imported.get(localName);\n    if (importData) {\n      if (isInType(path)) {\n        throw path.buildCodeFrameError(\n          `Cannot transform the imported binding \"${localName}\" since it's also used in a type annotation. ` +\n            `Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`,\n        );\n      }\n\n      const localBinding = path.scope.getBinding(localName);\n      const rootBinding = scope.getBinding(localName);\n\n      // redeclared in this scope\n      if (rootBinding !== localBinding) return;\n\n      const ref = buildImportReference(importData, path.node);\n\n      // Preserve the binding location so that sourcemaps are nicer.\n      ref.loc = path.node.loc;\n\n      if (\n        (path.parentPath.isCallExpression({ callee: path.node }) ||\n          path.parentPath.isOptionalCallExpression({ callee: path.node }) ||\n          path.parentPath.isTaggedTemplateExpression({ tag: path.node })) &&\n        isMemberExpression(ref)\n      ) {\n        path.replaceWith(sequenceExpression([numericLiteral(0), ref]));\n      } else if (path.isJSXIdentifier() && isMemberExpression(ref)) {\n        const { object, property } = ref;\n        path.replaceWith(\n          jsxMemberExpression(\n            // @ts-expect-error todo(flow->ts): possible bug `object` might not have a name\n            jsxIdentifier(object.name),\n            // @ts-expect-error todo(flow->ts): possible bug `property` might not have a name\n            jsxIdentifier(property.name),\n          ),\n        );\n      } else {\n        path.replaceWith(ref);\n      }\n\n      requeueInParent(path);\n\n      // The path could have been replaced with an identifier that would\n      // otherwise be re-visited, so we skip processing its children.\n      path.skip();\n    }\n  },\n\n  UpdateExpression(path) {\n    const {\n      scope,\n      seen,\n      imported,\n      exported,\n      requeueInParent,\n      buildImportReference,\n    } = this;\n\n    if (seen.has(path.node)) return;\n\n    seen.add(path.node);\n\n    const arg = path.get(\"argument\");\n\n    // No change needed\n    if (arg.isMemberExpression()) return;\n\n    const update = path.node;\n\n    if (arg.isIdentifier()) {\n      const localName = arg.node.name;\n\n      // redeclared in this scope\n      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n        return;\n      }\n\n      const exportedNames = exported.get(localName);\n      const importData = imported.get(localName);\n\n      if (exportedNames?.length > 0 || importData) {\n        if (importData) {\n          path.replaceWith(\n            assignmentExpression(\n              update.operator[0] + \"=\",\n              buildImportReference(importData, arg.node),\n              buildImportThrow(localName),\n            ),\n          );\n        } else if (update.prefix) {\n          // ++foo\n          // =>   exports.foo = ++foo\n          path.replaceWith(\n            buildBindingExportAssignmentExpression(\n              this.metadata,\n              exportedNames,\n              cloneNode(update),\n              path.scope,\n            ),\n          );\n        } else {\n          // foo++\n          // =>   (ref = i++, exports.i = i, ref)\n          const ref = scope.generateDeclaredUidIdentifier(localName);\n\n          path.replaceWith(\n            sequenceExpression([\n              assignmentExpression(\"=\", cloneNode(ref), cloneNode(update)),\n              buildBindingExportAssignmentExpression(\n                this.metadata,\n                exportedNames,\n                identifier(localName),\n                path.scope,\n              ),\n              cloneNode(ref),\n            ]),\n          );\n        }\n      }\n    }\n\n    requeueInParent(path);\n    path.skip();\n  },\n\n  AssignmentExpression: {\n    exit(path) {\n      const {\n        scope,\n        seen,\n        imported,\n        exported,\n        requeueInParent,\n        buildImportReference,\n      } = this;\n\n      if (seen.has(path.node)) return;\n      seen.add(path.node);\n\n      const left = path.get(\"left\");\n\n      // No change needed\n      if (left.isMemberExpression()) return;\n\n      if (left.isIdentifier()) {\n        // Simple update-assign foo += 1; export { foo };\n        // =>   exports.foo =  (foo += 1);\n        const localName = left.node.name;\n\n        // redeclared in this scope\n        if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n          return;\n        }\n\n        const exportedNames = exported.get(localName);\n        const importData = imported.get(localName);\n        if (exportedNames?.length > 0 || importData) {\n          assert(path.node.operator === \"=\", \"Path was not simplified\");\n\n          const assignment = path.node;\n\n          if (importData) {\n            assignment.left = buildImportReference(importData, left.node);\n\n            assignment.right = sequenceExpression([\n              assignment.right,\n              buildImportThrow(localName),\n            ]);\n          }\n\n          path.replaceWith(\n            buildBindingExportAssignmentExpression(\n              this.metadata,\n              exportedNames,\n              assignment,\n              path.scope,\n            ),\n          );\n          requeueInParent(path);\n        }\n      } else {\n        const ids = left.getOuterBindingIdentifiers();\n        const programScopeIds = Object.keys(ids).filter(\n          localName =>\n            scope.getBinding(localName) === path.scope.getBinding(localName),\n        );\n        const id = programScopeIds.find(localName => imported.has(localName));\n\n        if (id) {\n          path.node.right = sequenceExpression([\n            path.node.right,\n            buildImportThrow(id),\n          ]);\n        }\n\n        // Complex ({a, b, c} = {}); export { a, c };\n        // =>   ({a, b, c} = {}), (exports.a = a, exports.c = c);\n        const items: t.Expression[] = [];\n        programScopeIds.forEach(localName => {\n          const exportedNames = exported.get(localName) || [];\n          if (exportedNames.length > 0) {\n            items.push(\n              buildBindingExportAssignmentExpression(\n                this.metadata,\n                exportedNames,\n                identifier(localName),\n                path.scope,\n              ),\n            );\n          }\n        });\n\n        if (items.length > 0) {\n          let node: t.Node = sequenceExpression(items);\n          if (path.parentPath.isExpressionStatement()) {\n            node = expressionStatement(node);\n            // @ts-expect-error todo(flow->ts): avoid mutations\n            node._blockHoist = path.parentPath.node._blockHoist;\n          }\n\n          const statement = path.insertAfter(node)[0];\n          requeueInParent(statement);\n        }\n      }\n    },\n  },\n  \"ForOfStatement|ForInStatement\"(\n    path: NodePath<t.ForOfStatement | t.ForInStatement>,\n  ) {\n    const { scope, node } = path;\n    const { left } = node;\n    const { exported, imported, scope: programScope } = this;\n\n    if (!isVariableDeclaration(left)) {\n      let didTransformExport = false,\n        importConstViolationName;\n      const loopBodyScope = path.get(\"body\").scope;\n      for (const name of Object.keys(getOuterBindingIdentifiers(left))) {\n        if (programScope.getBinding(name) === scope.getBinding(name)) {\n          if (exported.has(name)) {\n            didTransformExport = true;\n            if (loopBodyScope.hasOwnBinding(name)) {\n              loopBodyScope.rename(name);\n            }\n          }\n          if (imported.has(name) && !importConstViolationName) {\n            importConstViolationName = name;\n          }\n        }\n      }\n      if (!didTransformExport && !importConstViolationName) {\n        return;\n      }\n\n      path.ensureBlock();\n      const bodyPath = path.get(\"body\");\n\n      const newLoopId = scope.generateUidIdentifierBasedOnNode(left);\n      path\n        .get(\"left\")\n        .replaceWith(\n          variableDeclaration(\"let\", [\n            variableDeclarator(cloneNode(newLoopId)),\n          ]),\n        );\n      scope.registerDeclaration(path.get(\"left\"));\n\n      if (didTransformExport) {\n        bodyPath.unshiftContainer(\n          \"body\",\n          expressionStatement(assignmentExpression(\"=\", left, newLoopId)),\n        );\n      }\n      if (importConstViolationName) {\n        bodyPath.unshiftContainer(\n          \"body\",\n          expressionStatement(buildImportThrow(importConstViolationName)),\n        );\n      }\n    }\n  },\n};\n","import { basename, extname } from \"path\";\nimport type * as t from \"@babel/types\";\n\nimport { isIdentifierName } from \"@babel/helper-validator-identifier\";\nimport splitExportDeclaration from \"@babel/helper-split-export-declaration\";\nimport type { NodePath } from \"@babel/traverse\";\n\nexport interface ModuleMetadata {\n  exportName: string;\n  // The name of the variable that will reference an object containing export names.\n  exportNameListName: null | string;\n  hasExports: boolean;\n  // Lookup from local binding to export information.\n  local: Map<string, LocalExportMetadata>;\n  // Lookup of source file to source file metadata.\n  source: Map<string, SourceModuleMetadata>;\n  // List of names that should only be printed as string literals.\n  // i.e. `import { \"any unicode\" as foo } from \"some-module\"`\n  // `stringSpecifiers` is Set(1) [\"any unicode\"]\n  // In most cases `stringSpecifiers` is an empty Set\n  stringSpecifiers: Set<string>;\n}\n\nexport type InteropType =\n  | \"default\" // Babel interop for default-only imports\n  | \"namespace\" // Babel interop for namespace or default+named imports\n  | \"node-default\" // Node.js interop for default-only imports\n  | \"node-namespace\" // Node.js interop for namespace or default+named imports\n  | \"none\"; // No interop, or named-only imports\n\nexport type ImportInterop =\n  | \"none\"\n  | \"babel\"\n  | \"node\"\n  | ((source: string, filename?: string) => \"none\" | \"babel\" | \"node\");\n\nexport interface SourceModuleMetadata {\n  // A unique variable name to use for this namespace object. Centralized for simplicity.\n  name: string;\n  loc: t.SourceLocation | undefined | null;\n  interop: InteropType;\n  // Local binding to reference from this source namespace. Key: Local name, value: Import name\n  imports: Map<string, string>;\n  // Local names that reference namespace object.\n  importsNamespace: Set<string>;\n  // Reexports to create for namespace. Key: Export name, value: Import name\n  reexports: Map<string, string>;\n  // List of names to re-export namespace as.\n  reexportNamespace: Set<string>;\n  // Tracks if the source should be re-exported.\n  reexportAll: null | {\n    loc: t.SourceLocation | undefined | null;\n  };\n  wrap?: unknown;\n  referenced: boolean;\n}\n\nexport interface LocalExportMetadata {\n  names: Array<string>; // names of exports,\n  kind: \"import\" | \"hoisted\" | \"block\" | \"var\";\n}\n\n/**\n * Check if the module has any exports that need handling.\n */\nexport function hasExports(metadata: ModuleMetadata) {\n  return metadata.hasExports;\n}\n\n/**\n * Check if a given source is an anonymous import, e.g. \"import 'foo';\"\n */\nexport function isSideEffectImport(source: SourceModuleMetadata) {\n  return (\n    source.imports.size === 0 &&\n    source.importsNamespace.size === 0 &&\n    source.reexports.size === 0 &&\n    source.reexportNamespace.size === 0 &&\n    !source.reexportAll\n  );\n}\n\nexport function validateImportInteropOption(\n  importInterop: any,\n): importInterop is ImportInterop {\n  if (\n    typeof importInterop !== \"function\" &&\n    importInterop !== \"none\" &&\n    importInterop !== \"babel\" &&\n    importInterop !== \"node\"\n  ) {\n    throw new Error(\n      `.importInterop must be one of \"none\", \"babel\", \"node\", or a function returning one of those values (received ${importInterop}).`,\n    );\n  }\n  return importInterop;\n}\n\nfunction resolveImportInterop(\n  importInterop: ImportInterop,\n  source: string,\n  filename: string | undefined,\n) {\n  if (typeof importInterop === \"function\") {\n    return validateImportInteropOption(importInterop(source, filename));\n  }\n  return importInterop;\n}\n\n/**\n * Remove all imports and exports from the file, and return all metadata\n * needed to reconstruct the module's behavior.\n */\nexport default function normalizeModuleAndLoadMetadata(\n  programPath: NodePath<t.Program>,\n  exportName: string,\n  {\n    importInterop,\n    initializeReexports = false,\n    getWrapperPayload,\n    esNamespaceOnly = false,\n    filename,\n  }: {\n    importInterop: ImportInterop;\n    initializeReexports: boolean | void;\n    getWrapperPayload?: (\n      source: string,\n      metadata: SourceModuleMetadata,\n      importNodes: t.Node[],\n    ) => unknown;\n    esNamespaceOnly: boolean;\n    filename: string;\n  },\n): ModuleMetadata {\n  if (!exportName) {\n    exportName = programPath.scope.generateUidIdentifier(\"exports\").name;\n  }\n  const stringSpecifiers = new Set<string>();\n\n  nameAnonymousExports(programPath);\n\n  const { local, sources, hasExports } = getModuleMetadata(\n    programPath,\n    { initializeReexports, getWrapperPayload },\n    stringSpecifiers,\n  );\n\n  removeImportExportDeclarations(programPath);\n\n  // Reuse the imported namespace name if there is one.\n  for (const [source, metadata] of sources) {\n    const { importsNamespace, imports } = metadata;\n    // If there is at least one namespace import and other imports, it may collipse with local ident, can be seen in issue 15879.\n    if (importsNamespace.size > 0 && imports.size === 0) {\n      const [nameOfnamespace] = importsNamespace;\n      metadata.name = nameOfnamespace;\n    }\n\n    const resolvedInterop = resolveImportInterop(\n      importInterop,\n      source,\n      filename,\n    );\n\n    if (resolvedInterop === \"none\") {\n      metadata.interop = \"none\";\n    } else if (resolvedInterop === \"node\" && metadata.interop === \"namespace\") {\n      metadata.interop = \"node-namespace\";\n    } else if (resolvedInterop === \"node\" && metadata.interop === \"default\") {\n      metadata.interop = \"node-default\";\n    } else if (esNamespaceOnly && metadata.interop === \"namespace\") {\n      // Both the default and namespace interops pass through __esModule\n      // objects, but the namespace interop is used to enable Babel's\n      // destructuring-like interop behavior for normal CommonJS.\n      // Since some tooling has started to remove that behavior, we expose\n      // it as the `esNamespace` option.\n      metadata.interop = \"default\";\n    }\n  }\n\n  return {\n    exportName,\n    exportNameListName: null,\n    hasExports,\n    local,\n    source: sources,\n    stringSpecifiers,\n  };\n}\n\nfunction getExportSpecifierName(\n  path: NodePath,\n  stringSpecifiers: Set<string>,\n): string {\n  if (path.isIdentifier()) {\n    return path.node.name;\n  } else if (path.isStringLiteral()) {\n    const stringValue = path.node.value;\n    // add specifier value to `stringSpecifiers` only when it can not be converted to an identifier name\n    // i.e In `import { \"foo\" as bar }`\n    // we do not consider `\"foo\"` to be a `stringSpecifier` because we can treat it as\n    // `import { foo as bar }`\n    // This helps minimize the size of `stringSpecifiers` and reduce overhead of checking valid identifier names\n    // when building transpiled code from metadata\n    if (!isIdentifierName(stringValue)) {\n      stringSpecifiers.add(stringValue);\n    }\n    return stringValue;\n  } else {\n    throw new Error(\n      `Expected export specifier to be either Identifier or StringLiteral, got ${path.node.type}`,\n    );\n  }\n}\n\nfunction assertExportSpecifier(\n  path: NodePath,\n): asserts path is NodePath<t.ExportSpecifier> {\n  if (path.isExportSpecifier()) {\n    return;\n  } else if (path.isExportNamespaceSpecifier()) {\n    throw path.buildCodeFrameError(\n      \"Export namespace should be first transformed by `@babel/plugin-transform-export-namespace-from`.\",\n    );\n  } else {\n    throw path.buildCodeFrameError(\"Unexpected export specifier type\");\n  }\n}\n\n/**\n * Get metadata about the imports and exports present in this module.\n */\nfunction getModuleMetadata(\n  programPath: NodePath<t.Program>,\n  {\n    getWrapperPayload,\n    initializeReexports,\n  }: {\n    getWrapperPayload?: (\n      source: string,\n      metadata: SourceModuleMetadata,\n      importNodes: t.Node[],\n    ) => unknown;\n    initializeReexports: boolean | void;\n  },\n  stringSpecifiers: Set<string>,\n) {\n  const localData = getLocalExportMetadata(\n    programPath,\n    initializeReexports,\n    stringSpecifiers,\n  );\n\n  const importNodes = new Map<string, t.Node[]>();\n  const sourceData = new Map<string, SourceModuleMetadata>();\n  const getData = (sourceNode: t.StringLiteral, node: t.Node) => {\n    const source = sourceNode.value;\n\n    let data = sourceData.get(source);\n    if (!data) {\n      data = {\n        name: programPath.scope.generateUidIdentifier(\n          basename(source, extname(source)),\n        ).name,\n\n        interop: \"none\",\n\n        loc: null,\n\n        // Data about the requested sources and names.\n        imports: new Map(),\n        importsNamespace: new Set(),\n\n        // Metadata about data that is passed directly from source to export.\n        reexports: new Map(),\n        reexportNamespace: new Set(),\n        reexportAll: null,\n\n        wrap: null,\n\n        // @ts-expect-error lazy is not listed in the type.\n        // This is needed for compatibility with older version of the commonjs\n        // plusing.\n        // TODO(Babel 8): Remove this\n        get lazy() {\n          return this.wrap === \"lazy\";\n        },\n\n        referenced: false,\n      };\n      sourceData.set(source, data);\n      importNodes.set(source, [node]);\n    } else {\n      importNodes.get(source).push(node);\n    }\n    return data;\n  };\n  let hasExports = false;\n  programPath.get(\"body\").forEach(child => {\n    if (child.isImportDeclaration()) {\n      const data = getData(child.node.source, child.node);\n      if (!data.loc) data.loc = child.node.loc;\n\n      child.get(\"specifiers\").forEach(spec => {\n        if (spec.isImportDefaultSpecifier()) {\n          const localName = spec.get(\"local\").node.name;\n\n          data.imports.set(localName, \"default\");\n\n          const reexport = localData.get(localName);\n          if (reexport) {\n            localData.delete(localName);\n\n            reexport.names.forEach(name => {\n              data.reexports.set(name, \"default\");\n            });\n            data.referenced = true;\n          }\n        } else if (spec.isImportNamespaceSpecifier()) {\n          const localName = spec.get(\"local\").node.name;\n\n          data.importsNamespace.add(localName);\n          const reexport = localData.get(localName);\n          if (reexport) {\n            localData.delete(localName);\n\n            reexport.names.forEach(name => {\n              data.reexportNamespace.add(name);\n            });\n            data.referenced = true;\n          }\n        } else if (spec.isImportSpecifier()) {\n          const importName = getExportSpecifierName(\n            spec.get(\"imported\"),\n            stringSpecifiers,\n          );\n          const localName = spec.get(\"local\").node.name;\n\n          data.imports.set(localName, importName);\n\n          const reexport = localData.get(localName);\n          if (reexport) {\n            localData.delete(localName);\n\n            reexport.names.forEach(name => {\n              data.reexports.set(name, importName);\n            });\n            data.referenced = true;\n          }\n        }\n      });\n    } else if (child.isExportAllDeclaration()) {\n      hasExports = true;\n      const data = getData(child.node.source, child.node);\n      if (!data.loc) data.loc = child.node.loc;\n\n      data.reexportAll = {\n        loc: child.node.loc,\n      };\n      data.referenced = true;\n    } else if (child.isExportNamedDeclaration() && child.node.source) {\n      hasExports = true;\n      const data = getData(child.node.source, child.node);\n      if (!data.loc) data.loc = child.node.loc;\n\n      child.get(\"specifiers\").forEach(spec => {\n        assertExportSpecifier(spec);\n        const importName = getExportSpecifierName(\n          spec.get(\"local\"),\n          stringSpecifiers,\n        );\n        const exportName = getExportSpecifierName(\n          spec.get(\"exported\"),\n          stringSpecifiers,\n        );\n\n        data.reexports.set(exportName, importName);\n        data.referenced = true;\n\n        if (exportName === \"__esModule\") {\n          throw spec\n            .get(\"exported\")\n            .buildCodeFrameError('Illegal export \"__esModule\".');\n        }\n      });\n    } else if (\n      child.isExportNamedDeclaration() ||\n      child.isExportDefaultDeclaration()\n    ) {\n      hasExports = true;\n    }\n  });\n\n  for (const metadata of sourceData.values()) {\n    let needsDefault = false;\n    let needsNamed = false;\n\n    if (metadata.importsNamespace.size > 0) {\n      needsDefault = true;\n      needsNamed = true;\n    }\n\n    if (metadata.reexportAll) {\n      needsNamed = true;\n    }\n\n    for (const importName of metadata.imports.values()) {\n      if (importName === \"default\") needsDefault = true;\n      else needsNamed = true;\n    }\n    for (const importName of metadata.reexports.values()) {\n      if (importName === \"default\") needsDefault = true;\n      else needsNamed = true;\n    }\n\n    if (needsDefault && needsNamed) {\n      // TODO(logan): Using the namespace interop here is unfortunate. Revisit.\n      metadata.interop = \"namespace\";\n    } else if (needsDefault) {\n      metadata.interop = \"default\";\n    }\n  }\n\n  if (getWrapperPayload) {\n    for (const [source, metadata] of sourceData) {\n      metadata.wrap = getWrapperPayload(\n        source,\n        metadata,\n        importNodes.get(source),\n      );\n    }\n  }\n\n  return {\n    hasExports,\n    local: localData,\n    sources: sourceData,\n  };\n}\n\ntype ModuleBindingKind = \"import\" | \"hoisted\" | \"block\" | \"var\";\n/**\n * Get metadata about local variables that are exported.\n */\nfunction getLocalExportMetadata(\n  programPath: NodePath<t.Program>,\n  initializeReexports: boolean | void,\n  stringSpecifiers: Set<string>,\n): Map<string, LocalExportMetadata> {\n  const bindingKindLookup = new Map();\n\n  programPath.get(\"body\").forEach((child: NodePath) => {\n    let kind: ModuleBindingKind;\n    if (child.isImportDeclaration()) {\n      kind = \"import\";\n    } else {\n      if (child.isExportDefaultDeclaration()) {\n        child = child.get(\"declaration\");\n      }\n      if (child.isExportNamedDeclaration()) {\n        if (child.node.declaration) {\n          child = child.get(\"declaration\");\n        } else if (\n          initializeReexports &&\n          child.node.source &&\n          child.get(\"source\").isStringLiteral()\n        ) {\n          child.get(\"specifiers\").forEach(spec => {\n            assertExportSpecifier(spec);\n            bindingKindLookup.set(spec.get(\"local\").node.name, \"block\");\n          });\n          return;\n        }\n      }\n\n      if (child.isFunctionDeclaration()) {\n        kind = \"hoisted\";\n      } else if (child.isClassDeclaration()) {\n        kind = \"block\";\n      } else if (child.isVariableDeclaration({ kind: \"var\" })) {\n        kind = \"var\";\n      } else if (child.isVariableDeclaration()) {\n        kind = \"block\";\n      } else {\n        return;\n      }\n    }\n\n    Object.keys(child.getOuterBindingIdentifiers()).forEach(name => {\n      bindingKindLookup.set(name, kind);\n    });\n  });\n\n  const localMetadata = new Map();\n  const getLocalMetadata = (idPath: NodePath<t.Identifier>) => {\n    const localName = idPath.node.name;\n    let metadata = localMetadata.get(localName);\n\n    if (!metadata) {\n      const kind = bindingKindLookup.get(localName);\n\n      if (kind === undefined) {\n        throw idPath.buildCodeFrameError(\n          `Exporting local \"${localName}\", which is not declared.`,\n        );\n      }\n\n      metadata = {\n        names: [],\n        kind,\n      };\n      localMetadata.set(localName, metadata);\n    }\n    return metadata;\n  };\n\n  programPath.get(\"body\").forEach(child => {\n    if (\n      child.isExportNamedDeclaration() &&\n      (initializeReexports || !child.node.source)\n    ) {\n      if (child.node.declaration) {\n        const declaration = child.get(\"declaration\");\n        const ids = declaration.getOuterBindingIdentifierPaths();\n        Object.keys(ids).forEach(name => {\n          if (name === \"__esModule\") {\n            throw declaration.buildCodeFrameError(\n              'Illegal export \"__esModule\".',\n            );\n          }\n          getLocalMetadata(ids[name]).names.push(name);\n        });\n      } else {\n        child.get(\"specifiers\").forEach(spec => {\n          const local = spec.get(\"local\");\n          const exported = spec.get(\"exported\");\n          const localMetadata = getLocalMetadata(local);\n          const exportName = getExportSpecifierName(exported, stringSpecifiers);\n\n          if (exportName === \"__esModule\") {\n            throw exported.buildCodeFrameError('Illegal export \"__esModule\".');\n          }\n          localMetadata.names.push(exportName);\n        });\n      }\n    } else if (child.isExportDefaultDeclaration()) {\n      const declaration = child.get(\"declaration\");\n      if (\n        declaration.isFunctionDeclaration() ||\n        declaration.isClassDeclaration()\n      ) {\n        // @ts-expect-error todo(flow->ts): improve babel-types\n        getLocalMetadata(declaration.get(\"id\")).names.push(\"default\");\n      } else {\n        // These should have been removed by the nameAnonymousExports() call.\n        throw declaration.buildCodeFrameError(\n          \"Unexpected default expression export.\",\n        );\n      }\n    }\n  });\n  return localMetadata;\n}\n\n/**\n * Ensure that all exported values have local binding names.\n */\nfunction nameAnonymousExports(programPath: NodePath<t.Program>) {\n  // Name anonymous exported locals.\n  programPath.get(\"body\").forEach(child => {\n    if (!child.isExportDefaultDeclaration()) return;\n    splitExportDeclaration(child);\n  });\n}\n\nfunction removeImportExportDeclarations(programPath: NodePath<t.Program>) {\n  programPath.get(\"body\").forEach(child => {\n    if (child.isImportDeclaration()) {\n      child.remove();\n    } else if (child.isExportNamedDeclaration()) {\n      if (child.node.declaration) {\n        // @ts-expect-error todo(flow->ts): avoid mutations\n        child.node.declaration._blockHoist = child.node._blockHoist;\n        child.replaceWith(child.node.declaration);\n      } else {\n        child.remove();\n      }\n    } else if (child.isExportDefaultDeclaration()) {\n      // export default foo;\n      const declaration = child.get(\"declaration\");\n      if (\n        declaration.isFunctionDeclaration() ||\n        declaration.isClassDeclaration()\n      ) {\n        // @ts-expect-error todo(flow->ts): avoid mutations\n        declaration._blockHoist = child.node._blockHoist;\n        child.replaceWith(\n          declaration as NodePath<t.FunctionDeclaration | t.ClassDeclaration>,\n        );\n      } else {\n        // These should have been removed by the nameAnonymousExports() call.\n        throw declaration.buildCodeFrameError(\n          \"Unexpected default expression export.\",\n        );\n      }\n    } else if (child.isExportAllDeclaration()) {\n      child.remove();\n    }\n  });\n}\n","// TODO: Move `lazy` implementation logic into the CommonJS plugin, since other\n// modules systems do not support `lazy`.\n\nimport { types as t } from \"@babel/core\";\nimport {\n  type SourceModuleMetadata,\n  isSideEffectImport,\n} from \"./normalize-and-load-metadata.ts\";\n\nexport type Lazy = boolean | string[] | ((source: string) => boolean);\n\nexport function toGetWrapperPayload(lazy: Lazy) {\n  return (source: string, metadata: SourceModuleMetadata): null | \"lazy\" => {\n    if (lazy === false) return null;\n    if (isSideEffectImport(metadata) || metadata.reexportAll) return null;\n    if (lazy === true) {\n      // 'true' means that local relative files are eagerly loaded and\n      // dependency modules are loaded lazily.\n      return /\\./.test(source) ? null : \"lazy\";\n    }\n    if (Array.isArray(lazy)) {\n      return lazy.indexOf(source) === -1 ? null : \"lazy\";\n    }\n    if (typeof lazy === \"function\") {\n      return lazy(source) ? \"lazy\" : null;\n    }\n    throw new Error(`.lazy must be a boolean, string array, or function`);\n  };\n}\n\nexport function wrapReference(\n  ref: t.Identifier,\n  payload: unknown,\n): t.Expression | null {\n  if (payload === \"lazy\") return t.callExpression(ref, []);\n  return null;\n}\n","// Heavily inspired by\n// https://github.com/airbnb/babel-plugin-dynamic-import-node/blob/master/src/utils.js\n\nimport { types as t, template } from \"@babel/core\";\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM && !IS_STANDALONE) {\n  // eslint-disable-next-line no-restricted-globals\n  exports.getDynamicImportSource = function getDynamicImportSource(\n    node: t.CallExpression,\n  ): t.StringLiteral | t.TemplateLiteral {\n    const [source] = node.arguments;\n\n    return t.isStringLiteral(source) || t.isTemplateLiteral(source)\n      ? source\n      : (template.expression.ast`\\`\\${${source}}\\`` as t.TemplateLiteral);\n  };\n}\n\nexport function buildDynamicImport(\n  node: t.CallExpression | t.ImportExpression,\n  deferToThen: boolean,\n  wrapWithPromise: boolean,\n  builder: (specifier: t.Expression) => t.Expression,\n): t.Expression {\n  const specifier = t.isCallExpression(node) ? node.arguments[0] : node.source;\n\n  if (\n    t.isStringLiteral(specifier) ||\n    (t.isTemplateLiteral(specifier) && specifier.quasis.length === 0)\n  ) {\n    if (deferToThen) {\n      return template.expression.ast`\n        Promise.resolve().then(() => ${builder(specifier)})\n      `;\n    } else return builder(specifier);\n  }\n\n  const specifierToString = t.isTemplateLiteral(specifier)\n    ? t.identifier(\"specifier\")\n    : t.templateLiteral(\n        [t.templateElement({ raw: \"\" }), t.templateElement({ raw: \"\" })],\n        [t.identifier(\"specifier\")],\n      );\n\n  if (deferToThen) {\n    return template.expression.ast`\n      (specifier =>\n        new Promise(r => r(${specifierToString}))\n          .then(s => ${builder(t.identifier(\"s\"))})\n      )(${specifier})\n    `;\n  } else if (wrapWithPromise) {\n    return template.expression.ast`\n      (specifier =>\n        new Promise(r => r(${builder(specifierToString)}))\n      )(${specifier})\n    `;\n  } else {\n    return template.expression.ast`\n      (specifier => ${builder(specifierToString)})(${specifier})\n    `;\n  }\n}\n","type RootOptions = {\n  filename?: string;\n  filenameRelative?: string;\n  sourceRoot?: string;\n};\n\nexport type PluginOptions = {\n  moduleId?: string;\n  moduleIds?: boolean;\n  getModuleId?: (moduleName: string) => string | null | undefined;\n  moduleRoot?: string;\n};\n\nif (!process.env.BABEL_8_BREAKING) {\n  const originalGetModuleName = getModuleName;\n\n  // @ts-expect-error TS doesn't like reassigning a function.\n  // eslint-disable-next-line no-func-assign\n  getModuleName = function getModuleName(\n    rootOpts: RootOptions & PluginOptions,\n    pluginOpts: PluginOptions,\n  ): string | null {\n    return originalGetModuleName(rootOpts, {\n      moduleId: pluginOpts.moduleId ?? rootOpts.moduleId,\n      moduleIds: pluginOpts.moduleIds ?? rootOpts.moduleIds,\n      getModuleId: pluginOpts.getModuleId ?? rootOpts.getModuleId,\n      moduleRoot: pluginOpts.moduleRoot ?? rootOpts.moduleRoot,\n    });\n  };\n}\n\nexport default function getModuleName(\n  rootOpts: RootOptions,\n  pluginOpts: PluginOptions,\n): string | null {\n  const {\n    filename,\n    filenameRelative = filename,\n    sourceRoot = pluginOpts.moduleRoot,\n  } = rootOpts;\n\n  const {\n    moduleId,\n    moduleIds = !!moduleId,\n\n    getModuleId,\n\n    moduleRoot = sourceRoot,\n  } = pluginOpts;\n\n  if (!moduleIds) return null;\n\n  // moduleId is n/a if a `getModuleId()` is provided\n  if (moduleId != null && !getModuleId) {\n    return moduleId;\n  }\n\n  let moduleName = moduleRoot != null ? moduleRoot + \"/\" : \"\";\n\n  if (filenameRelative) {\n    const sourceRootReplacer =\n      sourceRoot != null ? new RegExp(\"^\" + sourceRoot + \"/?\") : \"\";\n\n    moduleName += filenameRelative\n      // remove sourceRoot from filename\n      .replace(sourceRootReplacer, \"\")\n      // remove extension\n      .replace(/\\.(\\w*?)$/, \"\");\n  }\n\n  // normalize path separators\n  moduleName = moduleName.replace(/\\\\/g, \"/\");\n\n  if (getModuleId) {\n    // If return is falsy, assume they want us to use our generated default name\n    return getModuleId(moduleName) || moduleName;\n  } else {\n    return moduleName;\n  }\n}\n","import assert from \"assert\";\nimport { template, types as t } from \"@babel/core\";\n\nimport { isModule } from \"@babel/helper-module-imports\";\n\nimport rewriteThis from \"./rewrite-this.ts\";\nimport rewriteLiveReferences from \"./rewrite-live-references.ts\";\nimport normalizeModuleAndLoadMetadata, {\n  hasExports,\n  isSideEffectImport,\n  validateImportInteropOption,\n} from \"./normalize-and-load-metadata.ts\";\nimport type {\n  ImportInterop,\n  InteropType,\n  ModuleMetadata,\n  SourceModuleMetadata,\n} from \"./normalize-and-load-metadata.ts\";\nimport * as Lazy from \"./lazy-modules.ts\";\nimport type { NodePath } from \"@babel/traverse\";\n\nconst {\n  booleanLiteral,\n  callExpression,\n  cloneNode,\n  directive,\n  directiveLiteral,\n  expressionStatement,\n  identifier,\n  isIdentifier,\n  memberExpression,\n  stringLiteral,\n  valueToNode,\n  variableDeclaration,\n  variableDeclarator,\n} = t;\n\nexport { buildDynamicImport } from \"./dynamic-import.ts\";\n\nif (!process.env.BABEL_8_BREAKING && !USE_ESM && !IS_STANDALONE) {\n  // eslint-disable-next-line no-restricted-globals\n  exports.getDynamicImportSource =\n    // eslint-disable-next-line no-restricted-globals, import/extensions\n    require(\"./dynamic-import\").getDynamicImportSource;\n}\n\nexport { default as getModuleName } from \"./get-module-name.ts\";\nexport type { PluginOptions } from \"./get-module-name.ts\";\n\nexport { hasExports, isSideEffectImport, isModule, rewriteThis };\n\nexport interface RewriteModuleStatementsAndPrepareHeaderOptions {\n  exportName?: string;\n  strict: boolean;\n  allowTopLevelThis?: boolean;\n  strictMode: boolean;\n  loose?: boolean;\n  importInterop?: ImportInterop;\n  noInterop?: boolean;\n  lazy?: Lazy.Lazy;\n  getWrapperPayload?: (\n    source: string,\n    metadata: SourceModuleMetadata,\n    importNodes: t.Node[],\n  ) => unknown;\n  wrapReference?: (ref: t.Expression, payload: unknown) => t.Expression | null;\n  esNamespaceOnly?: boolean;\n  filename: string | undefined;\n  constantReexports?: boolean | void;\n  enumerableModuleMeta?: boolean | void;\n  noIncompleteNsImportDetection?: boolean | void;\n}\n\n/**\n * Perform all of the generic ES6 module rewriting needed to handle initial\n * module processing. This function will rewrite the majority of the given\n * program to reference the modules described by the returned metadata,\n * and returns a list of statements for use when initializing the module.\n */\nexport function rewriteModuleStatementsAndPrepareHeader(\n  path: NodePath<t.Program>,\n  {\n    exportName,\n    strict,\n    allowTopLevelThis,\n    strictMode,\n    noInterop,\n    importInterop = noInterop ? \"none\" : \"babel\",\n    // TODO(Babel 8): After that `lazy` implementation is moved to the CJS\n    // transform, remove this parameter.\n    lazy,\n    getWrapperPayload = Lazy.toGetWrapperPayload(lazy ?? false),\n    wrapReference = Lazy.wrapReference,\n    esNamespaceOnly,\n    filename,\n\n    constantReexports = process.env.BABEL_8_BREAKING\n      ? undefined\n      : arguments[1].loose,\n    enumerableModuleMeta = process.env.BABEL_8_BREAKING\n      ? undefined\n      : arguments[1].loose,\n    noIncompleteNsImportDetection,\n  }: RewriteModuleStatementsAndPrepareHeaderOptions,\n) {\n  validateImportInteropOption(importInterop);\n  assert(isModule(path), \"Cannot process module statements in a script\");\n  path.node.sourceType = \"script\";\n\n  const meta = normalizeModuleAndLoadMetadata(path, exportName, {\n    importInterop,\n    initializeReexports: constantReexports,\n    getWrapperPayload,\n    esNamespaceOnly,\n    filename,\n  });\n\n  if (!allowTopLevelThis) {\n    rewriteThis(path);\n  }\n\n  rewriteLiveReferences(path, meta, wrapReference);\n\n  if (strictMode !== false) {\n    const hasStrict = path.node.directives.some(directive => {\n      return directive.value.value === \"use strict\";\n    });\n    if (!hasStrict) {\n      path.unshiftContainer(\n        \"directives\",\n        directive(directiveLiteral(\"use strict\")),\n      );\n    }\n  }\n\n  const headers = [];\n  if (hasExports(meta) && !strict) {\n    headers.push(buildESModuleHeader(meta, enumerableModuleMeta));\n  }\n\n  const nameList = buildExportNameListDeclaration(path, meta);\n\n  if (nameList) {\n    meta.exportNameListName = nameList.name;\n    headers.push(nameList.statement);\n  }\n\n  // Create all of the statically known named exports.\n  headers.push(\n    ...buildExportInitializationStatements(\n      path,\n      meta,\n      wrapReference,\n      constantReexports,\n      noIncompleteNsImportDetection,\n    ),\n  );\n\n  return { meta, headers };\n}\n\n/**\n * Flag a set of statements as hoisted above all else so that module init\n * statements all run before user code.\n */\nexport function ensureStatementsHoisted(statements: t.Statement[]) {\n  // Force all of the header fields to be at the top of the file.\n  statements.forEach(header => {\n    // @ts-expect-error Fixme: handle _blockHoist property\n    header._blockHoist = 3;\n  });\n}\n\n/**\n * Given an expression for a standard import object, like \"require('foo')\",\n * wrap it in a call to the interop helpers based on the type.\n */\nexport function wrapInterop(\n  programPath: NodePath<t.Program>,\n  expr: t.Expression,\n  type: InteropType,\n): t.CallExpression {\n  if (type === \"none\") {\n    return null;\n  }\n\n  if (type === \"node-namespace\") {\n    return callExpression(programPath.hub.addHelper(\"interopRequireWildcard\"), [\n      expr,\n      booleanLiteral(true),\n    ]);\n  } else if (type === \"node-default\") {\n    return null;\n  }\n\n  let helper;\n  if (type === \"default\") {\n    helper = \"interopRequireDefault\";\n  } else if (type === \"namespace\") {\n    helper = \"interopRequireWildcard\";\n  } else {\n    throw new Error(`Unknown interop: ${type}`);\n  }\n\n  return callExpression(programPath.hub.addHelper(helper), [expr]);\n}\n\n/**\n * Create the runtime initialization statements for a given requested source.\n * These will initialize all of the runtime import/export logic that\n * can't be handled statically by the statements created by\n * buildExportInitializationStatements().\n */\nexport function buildNamespaceInitStatements(\n  metadata: ModuleMetadata,\n  sourceMetadata: SourceModuleMetadata,\n  constantReexports: boolean | void = false,\n  wrapReference: (\n    ref: t.Identifier,\n    payload: unknown,\n  ) => t.Expression | null = Lazy.wrapReference,\n) {\n  const statements = [];\n\n  const srcNamespaceId = identifier(sourceMetadata.name);\n\n  for (const localName of sourceMetadata.importsNamespace) {\n    if (localName === sourceMetadata.name) continue;\n\n    // Create and assign binding to namespace object\n    statements.push(\n      template.statement`var NAME = SOURCE;`({\n        NAME: localName,\n        SOURCE: cloneNode(srcNamespaceId),\n      }),\n    );\n  }\n\n  const srcNamespace =\n    wrapReference(srcNamespaceId, sourceMetadata.wrap) ?? srcNamespaceId;\n\n  if (constantReexports) {\n    statements.push(\n      ...buildReexportsFromMeta(metadata, sourceMetadata, true, wrapReference),\n    );\n  }\n  for (const exportName of sourceMetadata.reexportNamespace) {\n    // Assign export to namespace object.\n    statements.push(\n      (!t.isIdentifier(srcNamespace)\n        ? template.statement`\n            Object.defineProperty(EXPORTS, \"NAME\", {\n              enumerable: true,\n              get: function() {\n                return NAMESPACE;\n              }\n            });\n          `\n        : template.statement`EXPORTS.NAME = NAMESPACE;`)({\n        EXPORTS: metadata.exportName,\n        NAME: exportName,\n        NAMESPACE: cloneNode(srcNamespace),\n      }),\n    );\n  }\n  if (sourceMetadata.reexportAll) {\n    const statement = buildNamespaceReexport(\n      metadata,\n      cloneNode(srcNamespace),\n      constantReexports,\n    );\n    statement.loc = sourceMetadata.reexportAll.loc;\n\n    // Iterate props creating getter for each prop.\n    statements.push(statement);\n  }\n  return statements;\n}\n\nconst ReexportTemplate = {\n  constant: template.statement`EXPORTS.EXPORT_NAME = NAMESPACE_IMPORT;`,\n  constantComputed: template.statement`EXPORTS[\"EXPORT_NAME\"] = NAMESPACE_IMPORT;`,\n  spec: template.statement`\n    Object.defineProperty(EXPORTS, \"EXPORT_NAME\", {\n      enumerable: true,\n      get: function() {\n        return NAMESPACE_IMPORT;\n      },\n    });\n    `,\n};\n\nfunction buildReexportsFromMeta(\n  meta: ModuleMetadata,\n  metadata: SourceModuleMetadata,\n  constantReexports: boolean,\n  wrapReference: (ref: t.Expression, payload: unknown) => t.Expression | null,\n) {\n  let namespace: t.Expression = identifier(metadata.name);\n  namespace = wrapReference(namespace, metadata.wrap) ?? namespace;\n\n  const { stringSpecifiers } = meta;\n  return Array.from(metadata.reexports, ([exportName, importName]) => {\n    let NAMESPACE_IMPORT: t.Expression = cloneNode(namespace);\n    if (importName === \"default\" && metadata.interop === \"node-default\") {\n      // Nothing, it's ok as-is\n    } else if (stringSpecifiers.has(importName)) {\n      NAMESPACE_IMPORT = memberExpression(\n        NAMESPACE_IMPORT,\n        stringLiteral(importName),\n        true,\n      );\n    } else {\n      NAMESPACE_IMPORT = memberExpression(\n        NAMESPACE_IMPORT,\n        identifier(importName),\n      );\n    }\n    const astNodes = {\n      EXPORTS: meta.exportName,\n      EXPORT_NAME: exportName,\n      NAMESPACE_IMPORT,\n    };\n    if (constantReexports || isIdentifier(NAMESPACE_IMPORT)) {\n      if (stringSpecifiers.has(exportName)) {\n        return ReexportTemplate.constantComputed(astNodes);\n      } else {\n        return ReexportTemplate.constant(astNodes);\n      }\n    } else {\n      return ReexportTemplate.spec(astNodes);\n    }\n  });\n}\n\n/**\n * Build an \"__esModule\" header statement setting the property on a given object.\n */\nfunction buildESModuleHeader(\n  metadata: ModuleMetadata,\n  enumerableModuleMeta: boolean | void = false,\n) {\n  return (\n    enumerableModuleMeta\n      ? template.statement`\n        EXPORTS.__esModule = true;\n      `\n      : template.statement`\n        Object.defineProperty(EXPORTS, \"__esModule\", {\n          value: true,\n        });\n      `\n  )({ EXPORTS: metadata.exportName });\n}\n\n/**\n * Create a re-export initialization loop for a specific imported namespace.\n */\nfunction buildNamespaceReexport(\n  metadata: ModuleMetadata,\n  namespace: t.Expression,\n  constantReexports: boolean | void,\n) {\n  return (\n    constantReexports\n      ? template.statement`\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          EXPORTS[key] = NAMESPACE[key];\n        });\n      `\n      : // Also skip already assigned bindings if they are strictly equal\n        // to be somewhat more spec-compliant when a file has multiple\n        // namespace re-exports that would cause a binding to be exported\n        // multiple times. However, multiple bindings of the same name that\n        // export the same primitive value are silently skipped\n        // (the spec requires an \"ambiguous bindings\" early error here).\n        template.statement`\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          Object.defineProperty(EXPORTS, key, {\n            enumerable: true,\n            get: function() {\n              return NAMESPACE[key];\n            },\n          });\n        });\n    `\n  )({\n    NAMESPACE: namespace,\n    EXPORTS: metadata.exportName,\n    VERIFY_NAME_LIST: metadata.exportNameListName\n      ? template`\n            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;\n          `({ EXPORTS_LIST: metadata.exportNameListName })\n      : null,\n  });\n}\n\n/**\n * Build a statement declaring a variable that contains all of the exported\n * variable names in an object so they can easily be referenced from an\n * export * from statement to check for conflicts.\n */\nfunction buildExportNameListDeclaration(\n  programPath: NodePath,\n  metadata: ModuleMetadata,\n) {\n  const exportedVars = Object.create(null);\n  for (const data of metadata.local.values()) {\n    for (const name of data.names) {\n      exportedVars[name] = true;\n    }\n  }\n\n  let hasReexport = false;\n  for (const data of metadata.source.values()) {\n    for (const exportName of data.reexports.keys()) {\n      exportedVars[exportName] = true;\n    }\n    for (const exportName of data.reexportNamespace) {\n      exportedVars[exportName] = true;\n    }\n\n    hasReexport = hasReexport || !!data.reexportAll;\n  }\n\n  if (!hasReexport || Object.keys(exportedVars).length === 0) return null;\n\n  const name = programPath.scope.generateUidIdentifier(\"exportNames\");\n\n  delete exportedVars.default;\n\n  return {\n    name: name.name,\n    statement: variableDeclaration(\"var\", [\n      variableDeclarator(name, valueToNode(exportedVars)),\n    ]),\n  };\n}\n\n/**\n * Create a set of statements that will initialize all of the statically-known\n * export names with their expected values.\n */\nfunction buildExportInitializationStatements(\n  programPath: NodePath,\n  metadata: ModuleMetadata,\n  wrapReference: (ref: t.Expression, payload: unknown) => t.Expression | null,\n  constantReexports: boolean | void = false,\n  noIncompleteNsImportDetection: boolean | void = false,\n) {\n  const initStatements: Array<[string, t.Statement | null]> = [];\n\n  for (const [localName, data] of metadata.local) {\n    if (data.kind === \"import\") {\n      // No-open since these are explicitly set with the \"reexports\" block.\n    } else if (data.kind === \"hoisted\") {\n      initStatements.push([\n        // data.names is always of length 1 because a hoisted export\n        // name must be id of a function declaration\n        data.names[0],\n        buildInitStatement(metadata, data.names, identifier(localName)),\n      ]);\n    } else if (!noIncompleteNsImportDetection) {\n      for (const exportName of data.names) {\n        initStatements.push([exportName, null]);\n      }\n    }\n  }\n\n  for (const data of metadata.source.values()) {\n    if (!constantReexports) {\n      const reexportsStatements = buildReexportsFromMeta(\n        metadata,\n        data,\n        false,\n        wrapReference,\n      );\n      const reexports = [...data.reexports.keys()];\n      for (let i = 0; i < reexportsStatements.length; i++) {\n        initStatements.push([reexports[i], reexportsStatements[i]]);\n      }\n    }\n    if (!noIncompleteNsImportDetection) {\n      for (const exportName of data.reexportNamespace) {\n        initStatements.push([exportName, null]);\n      }\n    }\n  }\n\n  // https://tc39.es/ecma262/#sec-module-namespace-exotic-objects\n  // The [Exports] list is ordered as if an Array of those String values\n  // had been sorted using %Array.prototype.sort% using undefined as comparefn\n  initStatements.sort(([a], [b]) => {\n    if (a < b) return -1;\n    if (b < a) return 1;\n    return 0;\n  });\n\n  const results = [];\n  if (noIncompleteNsImportDetection) {\n    for (const [, initStatement] of initStatements) {\n      results.push(initStatement);\n    }\n  } else {\n    // We generate init statements (`exports.a = exports.b = ... = void 0`)\n    // for every 100 exported names to avoid deeply-nested AST structures.\n    const chunkSize = 100;\n    for (let i = 0; i < initStatements.length; i += chunkSize) {\n      let uninitializedExportNames = [];\n      for (let j = 0; j < chunkSize && i + j < initStatements.length; j++) {\n        const [exportName, initStatement] = initStatements[i + j];\n        if (initStatement !== null) {\n          if (uninitializedExportNames.length > 0) {\n            results.push(\n              buildInitStatement(\n                metadata,\n                uninitializedExportNames,\n                programPath.scope.buildUndefinedNode(),\n              ),\n            );\n            // reset after uninitializedExportNames has been transformed\n            // to init statements\n            uninitializedExportNames = [];\n          }\n          results.push(initStatement);\n        } else {\n          uninitializedExportNames.push(exportName);\n        }\n      }\n      if (uninitializedExportNames.length > 0) {\n        results.push(\n          buildInitStatement(\n            metadata,\n            uninitializedExportNames,\n            programPath.scope.buildUndefinedNode(),\n          ),\n        );\n      }\n    }\n  }\n\n  return results;\n}\n\n/**\n * Given a set of export names, create a set of nested assignments to\n * initialize them all to a given expression.\n */\nconst InitTemplate = {\n  computed: template.expression`EXPORTS[\"NAME\"] = VALUE`,\n  default: template.expression`EXPORTS.NAME = VALUE`,\n  define: template.expression`Object.defineProperty(EXPORTS, \"NAME\", { enumerable:true, value: void 0, writable: true })[\"NAME\"] = VALUE`,\n};\n\nfunction buildInitStatement(\n  metadata: ModuleMetadata,\n  exportNames: string[],\n  initExpr: t.Expression,\n) {\n  const { stringSpecifiers, exportName: EXPORTS } = metadata;\n  return expressionStatement(\n    exportNames.reduce((acc, exportName) => {\n      const params = {\n        EXPORTS,\n        NAME: exportName,\n        VALUE: acc,\n      };\n\n      if (exportName === \"__proto__\") {\n        return InitTemplate.define(params);\n      }\n\n      if (stringSpecifiers.has(exportName)) {\n        return InitTemplate.computed(params);\n      }\n\n      return InitTemplate.default(params);\n    }, initExpr),\n  );\n}\n"],"names":["numericLiteral","unaryExpression","t","rewriteThisVisitor","traverse","visitors","merge","environmentVisitor","ThisExpression","path","replaceWith","rewriteThis","programPath","node","Object","assign","noScope","assignmentExpression","cloneNode","expressionStatement","getOuterBindingIdentifiers","identifier","isArrowFunctionExpression","isClassExpression","isFunctionExpression","isIdentifier","isMemberExpression","isVariableDeclaration","jsxIdentifier","jsxMemberExpression","memberExpression","sequenceExpression","stringLiteral","variableDeclaration","variableDeclarator","isInType","parent","type","parentPath","exportKind","isStatement","isExpression","rewriteLiveReferences","metadata","wrapReference","imported","Map","exported","requeueInParent","requeue","source","data","localName","importName","imports","set","importsNamespace","local","exportMeta","get","push","names","rewriteBindingInitVisitorState","scope","rewriteBindingInitVisitor","bindingNames","Set","Array","from","keys","simplifyAccess","rewriteReferencesVisitorState","seen","WeakSet","buildImportReference","identNode","meta","referenced","wrap","namespace","name","interop","computed","stringSpecifiers","has","rewriteReferencesVisitor","Scope","skip","ClassDeclaration","id","Error","exportNames","length","statement","buildBindingExportAssignmentExpression","_blockHoist","insertAfter","VariableDeclaration","isVar","kind","decl","init","buildUndefinedNode","localExpr","exportsObjectName","exportName","currentScope","hasOwnBinding","rename","reduce","expr","buildImportThrow","template","expression","ast","ReferencedIdentifier","add","importData","buildCodeFrameError","localBinding","getBinding","rootBinding","ref","loc","isCallExpression","callee","isOptionalCallExpression","isTaggedTemplateExpression","tag","isJSXIdentifier","object","property","UpdateExpression","arg","update","exportedNames","operator","prefix","generateDeclaredUidIdentifier","AssignmentExpression","exit","left","assert","assignment","right","ids","programScopeIds","filter","find","items","forEach","isExpressionStatement","ForOfStatement|ForInStatement","programScope","didTransformExport","importConstViolationName","loopBodyScope","ensureBlock","bodyPath","newLoopId","generateUidIdentifierBasedOnNode","registerDeclaration","unshiftContainer","hasExports","isSideEffectImport","size","reexports","reexportNamespace","reexportAll","validateImportInteropOption","importInterop","resolveImportInterop","filename","normalizeModuleAndLoadMetadata","initializeReexports","getWrapperPayload","esNamespaceOnly","generateUidIdentifier","nameAnonymousExports","sources","getModuleMetadata","removeImportExportDeclarations","nameOfnamespace","resolvedInterop","exportNameListName","getExportSpecifierName","isStringLiteral","stringValue","value","isIdentifierName","assertExportSpecifier","isExportSpecifier","isExportNamespaceSpecifier","localData","getLocalExportMetadata","importNodes","sourceData","getData","sourceNode","basename","extname","lazy","child","isImportDeclaration","spec","isImportDefaultSpecifier","reexport","delete","isImportNamespaceSpecifier","isImportSpecifier","isExportAllDeclaration","isExportNamedDeclaration","isExportDefaultDeclaration","values","needsDefault","needsNamed","bindingKindLookup","declaration","isFunctionDeclaration","isClassDeclaration","localMetadata","getLocalMetadata","idPath","undefined","getOuterBindingIdentifierPaths","splitExportDeclaration","remove","toGetWrapperPayload","test","isArray","indexOf","payload","callExpression","buildDynamicImport","deferToThen","wrapWithPromise","builder","specifier","arguments","isTemplateLiteral","quasis","specifierToString","templateLiteral","templateElement","raw","getModuleName","rootOpts","pluginOpts","filenameRelative","sourceRoot","moduleRoot","moduleId","moduleIds","getModuleId","moduleName","sourceRootReplacer","RegExp","replace","booleanLiteral","directive","directiveLiteral","valueToNode","rewriteModuleStatementsAndPrepareHeader","strict","allowTopLevelThis","strictMode","noInterop","Lazy","constantReexports","enumerableModuleMeta","noIncompleteNsImportDetection","isModule","sourceType","hasStrict","directives","some","headers","buildESModuleHeader","nameList","buildExportNameListDeclaration","buildExportInitializationStatements","ensureStatementsHoisted","statements","header","wrapInterop","hub","addHelper","helper","buildNamespaceInitStatements","sourceMetadata","srcNamespaceId","NAME","SOURCE","srcNamespace","buildReexportsFromMeta","EXPORTS","NAMESPACE","buildNamespaceReexport","ReexportTemplate","constant","constantComputed","NAMESPACE_IMPORT","astNodes","EXPORT_NAME","VERIFY_NAME_LIST","EXPORTS_LIST","exportedVars","create","hasReexport","default","initStatements","buildInitStatement","reexportsStatements","i","sort","a","b","results","initStatement","chunkSize","uninitializedExportNames","j","InitTemplate","define","initExpr","acc","params","VALUE"],"mappings":"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"}