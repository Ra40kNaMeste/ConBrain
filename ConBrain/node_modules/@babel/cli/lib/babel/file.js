import convertSourceMap from "convert-source-map";
import { AnyMap, encodedMap } from "@jridgewell/trace-mapping";
import slash from "slash";
import path from "path";
import fs from "fs";
import * as util from "./util.js";
import * as watcher from "./watcher.js";
export default async function ({
  cliOptions,
  babelOptions
}) {
  function buildResult(fileResults) {
    const mapSections = [];
    let code = "";
    let offset = 0;
    let hasRawMap = false;
    for (const result of fileResults) {
      if (!result) continue;
      hasRawMap = !!result.map;
      mapSections.push({
        offset: {
          line: offset,
          column: 0
        },
        map: result.map || {
          version: 3,
          names: [],
          sources: [],
          mappings: []
        }
      });
      code += result.code + "\n";
      offset += countNewlines(result.code) + 1;
    }
    const map = new AnyMap({
      version: 3,
      file: cliOptions.sourceMapTarget || path.basename(cliOptions.outFile || "") || "stdout",
      sections: mapSections
    });
    map.sourceRoot = babelOptions.sourceRoot;
    if (babelOptions.sourceMaps === "inline" || !cliOptions.outFile && babelOptions.sourceMaps) {
      code += "\n" + convertSourceMap.fromObject(encodedMap(map)).toComment();
    }
    return {
      map: map,
      code: code,
      hasRawMap: hasRawMap
    };
  }
  function countNewlines(code) {
    let count = 0;
    let index = -1;
    while ((index = code.indexOf("\n", index + 1)) !== -1) {
      count++;
    }
    return count;
  }
  function output(fileResults) {
    const result = buildResult(fileResults);
    if (cliOptions.outFile) {
      fs.mkdirSync(path.dirname(cliOptions.outFile), {
        recursive: true
      });
      let outputMap = false;
      if (babelOptions.sourceMaps && babelOptions.sourceMaps !== "inline") {
        outputMap = "external";
      } else if (babelOptions.sourceMaps == undefined && result.hasRawMap) {
        outputMap = util.hasDataSourcemap(result.code) ? "external" : "both";
      }
      if (outputMap) {
        const mapLoc = cliOptions.outFile + ".map";
        if (outputMap === "external") {
          result.code = util.addSourceMappingUrl(result.code, mapLoc);
        }
        fs.writeFileSync(mapLoc, JSON.stringify(encodedMap(result.map)));
      }
      fs.writeFileSync(cliOptions.outFile, result.code);
    } else {
      process.stdout.write(result.code + "\n");
    }
  }
  function readStdin() {
    return new Promise((resolve, reject) => {
      let code = "";
      process.stdin.setEncoding("utf8");
      process.stdin.on("readable", function () {
        const chunk = process.stdin.read();
        if (chunk !== null) code += chunk;
      });
      process.stdin.on("end", function () {
        resolve(code);
      });
      process.stdin.on("error", reject);
    });
  }
  async function stdin() {
    const code = await readStdin();
    const res = await util.transformRepl(cliOptions.filename, code, Object.assign({}, babelOptions, {
      sourceFileName: "stdin"
    }));
    output([res]);
  }
  async function walk(filenames) {
    const _filenames = [];
    filenames.forEach(function (filename) {
      if (!fs.existsSync(filename)) return;
      const stat = fs.statSync(filename);
      if (stat.isDirectory()) {
        const dirname = filename;
        util.readdirForCompilable(filename, cliOptions.includeDotfiles, cliOptions.extensions).forEach(function (filename) {
          _filenames.push(path.join(dirname, filename));
        });
      } else {
        _filenames.push(filename);
      }
    });
    const results = await Promise.all(_filenames.map(async function (filename) {
      let sourceFilename = filename;
      if (cliOptions.outFile) {
        sourceFilename = path.relative(path.dirname(cliOptions.outFile), sourceFilename);
      }
      sourceFilename = slash(sourceFilename);
      try {
        return await util.compile(filename, Object.assign({}, babelOptions, {
          sourceFileName: sourceFilename,
          sourceMaps: babelOptions.sourceMaps === "inline" ? true : babelOptions.sourceMaps
        }));
      } catch (err) {
        if (!cliOptions.watch) {
          throw err;
        }
        console.error(err);
        return null;
      }
    }));
    output(results);
  }
  async function files(filenames) {
    if (cliOptions.watch) {
      watcher.enable({
        enableGlobbing: false
      });
    }
    if (!cliOptions.skipInitialBuild) {
      await walk(filenames);
    }
    if (cliOptions.watch) {
      filenames.forEach(watcher.watch);
      watcher.startWatcher();
      watcher.onFilesChange((changes, event, cause) => {
        const actionableChange = changes.some(filename => util.isCompilableExtension(filename, cliOptions.extensions) || filenames.includes(filename));
        if (!actionableChange) return;
        if (cliOptions.verbose) {
          console.log(`${event} ${cause}`);
        }
        walk(filenames).catch(err => {
          console.error(err);
        });
      });
    }
  }
  if (cliOptions.filenames.length) {
    await files(cliOptions.filenames);
  } else {
    await stdin();
  }
}

//# sourceMappingURL=file.js.map
