{"version":3,"names":["convertSourceMap","AnyMap","encodedMap","slash","path","fs","util","watcher","cliOptions","babelOptions","buildResult","fileResults","mapSections","code","offset","hasRawMap","result","map","push","line","column","version","names","sources","mappings","countNewlines","file","sourceMapTarget","basename","outFile","sections","sourceRoot","sourceMaps","fromObject","toComment","count","index","indexOf","output","mkdirSync","dirname","recursive","outputMap","undefined","hasDataSourcemap","mapLoc","addSourceMappingUrl","writeFileSync","JSON","stringify","process","stdout","write","readStdin","Promise","resolve","reject","stdin","setEncoding","on","chunk","read","res","transformRepl","filename","Object","assign","sourceFileName","walk","filenames","_filenames","forEach","existsSync","stat","statSync","isDirectory","readdirForCompilable","includeDotfiles","extensions","join","results","all","sourceFilename","relative","compile","err","watch","console","error","files","enable","enableGlobbing","skipInitialBuild","startWatcher","onFilesChange","changes","event","cause","actionableChange","some","isCompilableExtension","includes","verbose","log","catch","length"],"sources":["../../src/babel/file.ts"],"sourcesContent":["import convertSourceMap from \"convert-source-map\";\nimport { AnyMap, encodedMap } from \"@jridgewell/trace-mapping\";\nimport slash from \"slash\";\nimport path from \"path\";\nimport fs from \"fs\";\n\nimport * as util from \"./util.ts\";\nimport type { CmdOptions } from \"./options.ts\";\nimport * as watcher from \"./watcher.ts\";\n\nimport type {\n  EncodedSourceMap,\n  SectionedSourceMap,\n  SourceMapInput,\n  TraceMap,\n} from \"@jridgewell/trace-mapping\";\nimport type { FileResult } from \"@babel/core\";\n\ntype CompilationOutput = {\n  code: string;\n  map: SourceMapInput;\n  hasRawMap: boolean;\n};\n\nexport default async function ({\n  cliOptions,\n  babelOptions,\n}: CmdOptions): Promise<void> {\n  function buildResult(fileResults: Array<FileResult>): CompilationOutput {\n    const mapSections: SectionedSourceMap[\"sections\"] = [];\n\n    let code = \"\";\n    let offset = 0;\n\n    let hasRawMap = false;\n\n    for (const result of fileResults) {\n      if (!result) continue;\n\n      hasRawMap = !!result.map;\n\n      mapSections.push({\n        offset: { line: offset, column: 0 },\n        map: (result.map as EncodedSourceMap) || {\n          version: 3,\n          names: [],\n          sources: [],\n          mappings: [],\n        },\n      });\n\n      code += result.code + \"\\n\";\n      offset += countNewlines(result.code) + 1;\n    }\n\n    const map = new AnyMap({\n      version: 3,\n      file:\n        cliOptions.sourceMapTarget ||\n        path.basename(cliOptions.outFile || \"\") ||\n        \"stdout\",\n      sections: mapSections,\n    });\n    // For some reason, the spec doesn't allow sourceRoot when constructing a\n    // sectioned sourcemap. But AllMap returns a regular sourcemap, we can\n    // freely add to with a sourceRoot.\n    map.sourceRoot = babelOptions.sourceRoot;\n\n    // add the inline sourcemap comment if we've either explicitly asked for inline source\n    // maps, or we've requested them without any output file\n    if (\n      babelOptions.sourceMaps === \"inline\" ||\n      (!cliOptions.outFile && babelOptions.sourceMaps)\n    ) {\n      code += \"\\n\" + convertSourceMap.fromObject(encodedMap(map)).toComment();\n    }\n\n    return {\n      map: map,\n      code: code,\n      hasRawMap: hasRawMap,\n    };\n  }\n\n  function countNewlines(code: string): number {\n    let count = 0;\n    let index = -1;\n    while ((index = code.indexOf(\"\\n\", index + 1)) !== -1) {\n      count++;\n    }\n    return count;\n  }\n\n  function output(fileResults: Array<FileResult>): void {\n    const result = buildResult(fileResults);\n\n    if (cliOptions.outFile) {\n      fs.mkdirSync(path.dirname(cliOptions.outFile), { recursive: true });\n\n      let outputMap: \"both\" | \"external\" | false = false;\n      if (babelOptions.sourceMaps && babelOptions.sourceMaps !== \"inline\") {\n        outputMap = \"external\";\n      } else if (babelOptions.sourceMaps == undefined && result.hasRawMap) {\n        outputMap = util.hasDataSourcemap(result.code) ? \"external\" : \"both\";\n      }\n\n      if (outputMap) {\n        const mapLoc = cliOptions.outFile + \".map\";\n        if (outputMap === \"external\") {\n          result.code = util.addSourceMappingUrl(result.code, mapLoc);\n        }\n        fs.writeFileSync(\n          mapLoc,\n          JSON.stringify(encodedMap(result.map as TraceMap)),\n        );\n      }\n\n      fs.writeFileSync(cliOptions.outFile, result.code);\n    } else {\n      process.stdout.write(result.code + \"\\n\");\n    }\n  }\n\n  function readStdin(): Promise<string> {\n    return new Promise((resolve, reject): void => {\n      let code = \"\";\n\n      process.stdin.setEncoding(\"utf8\");\n\n      process.stdin.on(\"readable\", function () {\n        const chunk = process.stdin.read();\n        if (chunk !== null) code += chunk;\n      });\n\n      process.stdin.on(\"end\", function () {\n        resolve(code);\n      });\n      process.stdin.on(\"error\", reject);\n    });\n  }\n\n  async function stdin(): Promise<void> {\n    const code = await readStdin();\n\n    const res = await util.transformRepl(cliOptions.filename, code, {\n      ...babelOptions,\n      sourceFileName: \"stdin\",\n    });\n\n    output([res]);\n  }\n\n  async function walk(filenames: Array<string>): Promise<void> {\n    const _filenames: string[] = [];\n\n    filenames.forEach(function (filename) {\n      if (!fs.existsSync(filename)) return;\n\n      const stat = fs.statSync(filename);\n      if (stat.isDirectory()) {\n        const dirname = filename;\n\n        util\n          .readdirForCompilable(\n            filename,\n            cliOptions.includeDotfiles,\n            cliOptions.extensions,\n          )\n          .forEach(function (filename) {\n            _filenames.push(path.join(dirname, filename));\n          });\n      } else {\n        _filenames.push(filename);\n      }\n    });\n\n    const results = await Promise.all(\n      _filenames.map(async function (filename: string): Promise<any> {\n        let sourceFilename = filename;\n        if (cliOptions.outFile) {\n          sourceFilename = path.relative(\n            path.dirname(cliOptions.outFile),\n            sourceFilename,\n          );\n        }\n        sourceFilename = slash(sourceFilename);\n\n        try {\n          return await util.compile(filename, {\n            ...babelOptions,\n            sourceFileName: sourceFilename,\n            // Since we're compiling everything to be merged together,\n            // \"inline\" applies to the final output file, but not to the individual\n            // files being concatenated.\n            sourceMaps:\n              babelOptions.sourceMaps === \"inline\"\n                ? true\n                : babelOptions.sourceMaps,\n          });\n        } catch (err) {\n          if (!cliOptions.watch) {\n            throw err;\n          }\n\n          console.error(err);\n          return null;\n        }\n      }),\n    );\n\n    output(results);\n  }\n\n  async function files(filenames: Array<string>): Promise<void> {\n    if (cliOptions.watch) {\n      watcher.enable({ enableGlobbing: false });\n    }\n\n    if (!cliOptions.skipInitialBuild) {\n      await walk(filenames);\n    }\n\n    if (cliOptions.watch) {\n      filenames.forEach(watcher.watch);\n\n      watcher.startWatcher();\n\n      watcher.onFilesChange((changes, event, cause) => {\n        const actionableChange = changes.some(\n          filename =>\n            util.isCompilableExtension(filename, cliOptions.extensions) ||\n            filenames.includes(filename),\n        );\n        if (!actionableChange) return;\n\n        if (cliOptions.verbose) {\n          console.log(`${event} ${cause}`);\n        }\n\n        walk(filenames).catch(err => {\n          console.error(err);\n        });\n      });\n    }\n  }\n\n  if (cliOptions.filenames.length) {\n    await files(cliOptions.filenames);\n  } else {\n    await stdin();\n  }\n}\n"],"mappings":"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"}