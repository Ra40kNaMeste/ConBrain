{"version":3,"file":"index.js","sources":["../src/formatters.ts","../src/options.ts","../src/parse.ts","../src/populate.ts","../src/string.ts","../src/literal.ts","../src/builder.ts","../src/index.ts"],"sourcesContent":["import { assertExpressionStatement } from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nexport type Formatter<T> = {\n  code: (source: string) => string;\n  validate: (ast: t.File) => void;\n  unwrap: (ast: t.File) => T;\n};\n\nfunction makeStatementFormatter<T>(\n  fn: (statements: Array<t.Statement>) => T,\n): Formatter<T> {\n  return {\n    // We need to prepend a \";\" to force statement parsing so that\n    // ExpressionStatement strings won't be parsed as directives.\n    // Alongside that, we also prepend a comment so that when a syntax error\n    // is encountered, the user will be less likely to get confused about\n    // where the random semicolon came from.\n    code: str => `/* @babel/template */;\\n${str}`,\n    validate: () => {},\n    unwrap: (ast: t.File): T => {\n      return fn(ast.program.body.slice(1));\n    },\n  };\n}\n\nexport const smart = makeStatementFormatter(body => {\n  if (body.length > 1) {\n    return body;\n  } else {\n    return body[0];\n  }\n});\n\nexport const statements = makeStatementFormatter(body => body);\n\nexport const statement = makeStatementFormatter(body => {\n  // We do this validation when unwrapping since the replacement process\n  // could have added or removed statements.\n  if (body.length === 0) {\n    throw new Error(\"Found nothing to return.\");\n  }\n  if (body.length > 1) {\n    throw new Error(\"Found multiple statements but wanted one\");\n  }\n\n  return body[0];\n});\n\nexport const expression: Formatter<t.Expression> = {\n  code: str => `(\\n${str}\\n)`,\n  validate: ast => {\n    if (ast.program.body.length > 1) {\n      throw new Error(\"Found multiple statements but wanted one\");\n    }\n    if (expression.unwrap(ast).start === 0) {\n      throw new Error(\"Parse result included parens.\");\n    }\n  },\n  unwrap: ({ program }) => {\n    const [stmt] = program.body;\n    assertExpressionStatement(stmt);\n    return stmt.expression;\n  },\n};\n\nexport const program: Formatter<t.Program> = {\n  code: str => str,\n  validate: () => {},\n  unwrap: ast => ast.program,\n};\n","import type { ParserOptions as ParserOpts } from \"@babel/parser\";\n\nexport type { ParserOpts };\n\n/**\n * These are the options that 'babel-template' actually accepts and typechecks\n * when called. All other options are passed through to the parser.\n */\nexport type PublicOpts = {\n  /**\n   * A set of placeholder names to automatically accept, ignoring the given\n   * pattern entirely.\n   *\n   * This option can be used when using %%foo%% style placeholders.\n   */\n  placeholderWhitelist?: Set<string>;\n  /**\n   * A pattern to search for when looking for Identifier and StringLiteral\n   * nodes that can be replaced.\n   *\n   * 'false' will disable placeholder searching entirely, leaving only the\n   * 'placeholderWhitelist' value to find replacements.\n   *\n   * Defaults to /^[_$A-Z0-9]+$/.\n   *\n   * This option can be used when using %%foo%% style placeholders.\n   */\n  placeholderPattern?: RegExp | false;\n  /**\n   * 'true' to pass through comments from the template into the resulting AST,\n   * or 'false' to automatically discard comments. Defaults to 'false'.\n   */\n  preserveComments?: boolean;\n  /**\n   * 'true' to use %%foo%% style placeholders, 'false' to use legacy placeholders\n   * described by placeholderPattern or placeholderWhitelist.\n   * When it is not set, it behaves as 'true' if there are syntactic placeholders,\n   * otherwise as 'false'.\n   */\n  syntacticPlaceholders?: boolean | null;\n};\n\nexport type TemplateOpts = {\n  parser: ParserOpts;\n  placeholderWhitelist?: Set<string>;\n  placeholderPattern?: RegExp | false;\n  preserveComments?: boolean;\n  syntacticPlaceholders?: boolean;\n};\n\nexport function merge(a: TemplateOpts, b: TemplateOpts): TemplateOpts {\n  const {\n    placeholderWhitelist = a.placeholderWhitelist,\n    placeholderPattern = a.placeholderPattern,\n    preserveComments = a.preserveComments,\n    syntacticPlaceholders = a.syntacticPlaceholders,\n  } = b;\n\n  return {\n    parser: {\n      ...a.parser,\n      ...b.parser,\n    },\n    placeholderWhitelist,\n    placeholderPattern,\n    preserveComments,\n    syntacticPlaceholders,\n  };\n}\n\nexport function validate(opts: unknown): TemplateOpts {\n  if (opts != null && typeof opts !== \"object\") {\n    throw new Error(\"Unknown template options.\");\n  }\n\n  const {\n    placeholderWhitelist,\n    placeholderPattern,\n    preserveComments,\n    syntacticPlaceholders,\n    ...parser\n  } = opts || ({} as any);\n\n  if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set)) {\n    throw new Error(\n      \"'.placeholderWhitelist' must be a Set, null, or undefined\",\n    );\n  }\n\n  if (\n    placeholderPattern != null &&\n    !(placeholderPattern instanceof RegExp) &&\n    placeholderPattern !== false\n  ) {\n    throw new Error(\n      \"'.placeholderPattern' must be a RegExp, false, null, or undefined\",\n    );\n  }\n\n  if (preserveComments != null && typeof preserveComments !== \"boolean\") {\n    throw new Error(\n      \"'.preserveComments' must be a boolean, null, or undefined\",\n    );\n  }\n\n  if (\n    syntacticPlaceholders != null &&\n    typeof syntacticPlaceholders !== \"boolean\"\n  ) {\n    throw new Error(\n      \"'.syntacticPlaceholders' must be a boolean, null, or undefined\",\n    );\n  }\n  if (\n    syntacticPlaceholders === true &&\n    (placeholderWhitelist != null || placeholderPattern != null)\n  ) {\n    throw new Error(\n      \"'.placeholderWhitelist' and '.placeholderPattern' aren't compatible\" +\n        \" with '.syntacticPlaceholders: true'\",\n    );\n  }\n\n  return {\n    parser,\n    placeholderWhitelist: placeholderWhitelist || undefined,\n    placeholderPattern:\n      placeholderPattern == null ? undefined : placeholderPattern,\n    preserveComments: preserveComments == null ? undefined : preserveComments,\n    syntacticPlaceholders:\n      syntacticPlaceholders == null ? undefined : syntacticPlaceholders,\n  };\n}\n\nexport type PublicReplacements = { [x: string]: unknown } | Array<unknown>;\nexport type TemplateReplacements = { [x: string]: unknown } | void;\n\nexport function normalizeReplacements(\n  replacements: unknown,\n): TemplateReplacements {\n  if (Array.isArray(replacements)) {\n    return replacements.reduce((acc, replacement, i) => {\n      acc[\"$\" + i] = replacement;\n      return acc;\n    }, {});\n  } else if (typeof replacements === \"object\" || replacements == null) {\n    return (replacements as any) || undefined;\n  }\n\n  throw new Error(\n    \"Template replacements must be an array, object, null, or undefined\",\n  );\n}\n","import {\n  isCallExpression,\n  isExpressionStatement,\n  isFunction,\n  isIdentifier,\n  isJSXIdentifier,\n  isNewExpression,\n  isPlaceholder,\n  isStatement,\n  isStringLiteral,\n  removePropertiesDeep,\n  traverse,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type { TraversalAncestors } from \"@babel/types\";\nimport { parse } from \"@babel/parser\";\nimport { codeFrameColumns } from \"@babel/code-frame\";\nimport type { TemplateOpts, ParserOpts } from \"./options.ts\";\nimport type { Formatter } from \"./formatters.ts\";\n\nexport type Metadata = {\n  ast: t.File;\n  placeholders: Array<Placeholder>;\n  placeholderNames: Set<string>;\n};\n\ntype PlaceholderType = \"string\" | \"param\" | \"statement\" | \"other\";\nexport type Placeholder = {\n  name: string;\n  resolve: (a: t.File) => { parent: t.Node; key: string; index?: number };\n  type: PlaceholderType;\n  isDuplicate: boolean;\n};\n\nconst PATTERN = /^[_$A-Z0-9]+$/;\n\nexport default function parseAndBuildMetadata<T>(\n  formatter: Formatter<T>,\n  code: string,\n  opts: TemplateOpts,\n): Metadata {\n  const {\n    placeholderWhitelist,\n    placeholderPattern,\n    preserveComments,\n    syntacticPlaceholders,\n  } = opts;\n\n  const ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);\n\n  removePropertiesDeep(ast, {\n    preserveComments,\n  });\n\n  formatter.validate(ast);\n\n  const state: MetadataState = {\n    syntactic: { placeholders: [], placeholderNames: new Set() },\n    legacy: { placeholders: [], placeholderNames: new Set() },\n    placeholderWhitelist,\n    placeholderPattern,\n    syntacticPlaceholders,\n  };\n\n  traverse(ast, placeholderVisitorHandler, state);\n\n  return {\n    ast,\n    ...(state.syntactic.placeholders.length ? state.syntactic : state.legacy),\n  };\n}\n\nfunction placeholderVisitorHandler(\n  node: t.Node,\n  ancestors: TraversalAncestors,\n  state: MetadataState,\n) {\n  let name: string;\n\n  let hasSyntacticPlaceholders = state.syntactic.placeholders.length > 0;\n\n  if (isPlaceholder(node)) {\n    if (state.syntacticPlaceholders === false) {\n      throw new Error(\n        \"%%foo%%-style placeholders can't be used when \" +\n          \"'.syntacticPlaceholders' is false.\",\n      );\n    }\n    name = node.name.name;\n    hasSyntacticPlaceholders = true;\n  } else if (hasSyntacticPlaceholders || state.syntacticPlaceholders) {\n    return;\n  } else if (isIdentifier(node) || isJSXIdentifier(node)) {\n    name = node.name;\n  } else if (isStringLiteral(node)) {\n    name = node.value;\n  } else {\n    return;\n  }\n\n  if (\n    hasSyntacticPlaceholders &&\n    (state.placeholderPattern != null || state.placeholderWhitelist != null)\n  ) {\n    // This check is also in options.js. We need it there to handle the default\n    // .syntacticPlaceholders behavior.\n    throw new Error(\n      \"'.placeholderWhitelist' and '.placeholderPattern' aren't compatible\" +\n        \" with '.syntacticPlaceholders: true'\",\n    );\n  }\n\n  if (\n    !hasSyntacticPlaceholders &&\n    (state.placeholderPattern === false ||\n      !(state.placeholderPattern || PATTERN).test(name)) &&\n    !state.placeholderWhitelist?.has(name)\n  ) {\n    return;\n  }\n\n  // Keep our own copy of the ancestors so we can use it in .resolve().\n  ancestors = ancestors.slice();\n\n  const { node: parent, key } = ancestors[ancestors.length - 1];\n\n  let type: PlaceholderType;\n  if (\n    isStringLiteral(node) ||\n    isPlaceholder(node, { expectedNode: \"StringLiteral\" })\n  ) {\n    type = \"string\";\n  } else if (\n    (isNewExpression(parent) && key === \"arguments\") ||\n    (isCallExpression(parent) && key === \"arguments\") ||\n    (isFunction(parent) && key === \"params\")\n  ) {\n    type = \"param\";\n  } else if (isExpressionStatement(parent) && !isPlaceholder(node)) {\n    type = \"statement\";\n    ancestors = ancestors.slice(0, -1);\n  } else if (isStatement(node) && isPlaceholder(node)) {\n    type = \"statement\";\n  } else {\n    type = \"other\";\n  }\n\n  const { placeholders, placeholderNames } = !hasSyntacticPlaceholders\n    ? state.legacy\n    : state.syntactic;\n\n  placeholders.push({\n    name,\n    type,\n    resolve: ast => resolveAncestors(ast, ancestors),\n    isDuplicate: placeholderNames.has(name),\n  });\n  placeholderNames.add(name);\n}\n\nfunction resolveAncestors(ast: t.File, ancestors: TraversalAncestors) {\n  let parent: t.Node = ast;\n  for (let i = 0; i < ancestors.length - 1; i++) {\n    const { key, index } = ancestors[i];\n\n    if (index === undefined) {\n      parent = (parent as any)[key];\n    } else {\n      parent = (parent as any)[key][index];\n    }\n  }\n\n  const { key, index } = ancestors[ancestors.length - 1];\n\n  return { parent, key, index };\n}\n\ntype MetadataState = {\n  syntactic: {\n    placeholders: Array<Placeholder>;\n    placeholderNames: Set<string>;\n  };\n  legacy: {\n    placeholders: Array<Placeholder>;\n    placeholderNames: Set<string>;\n  };\n  placeholderWhitelist?: Set<string>;\n  placeholderPattern?: RegExp | false;\n  syntacticPlaceholders?: boolean;\n};\n\nfunction parseWithCodeFrame(\n  code: string,\n  parserOpts: ParserOpts,\n  syntacticPlaceholders?: boolean,\n): t.File {\n  const plugins = (parserOpts.plugins || []).slice();\n  if (syntacticPlaceholders !== false) {\n    plugins.push(\"placeholders\");\n  }\n\n  parserOpts = {\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    sourceType: \"module\",\n    ...parserOpts,\n    plugins,\n  };\n\n  try {\n    // @ts-expect-error todo: use babel-types ast typings in Babel parser\n    return parse(code, parserOpts);\n  } catch (err) {\n    const loc = err.loc;\n    if (loc) {\n      err.message += \"\\n\" + codeFrameColumns(code, { start: loc });\n      err.code = \"BABEL_TEMPLATE_PARSE_ERROR\";\n    }\n    throw err;\n  }\n}\n","import {\n  blockStatement,\n  cloneNode,\n  emptyStatement,\n  expressionStatement,\n  identifier,\n  isStatement,\n  isStringLiteral,\n  stringLiteral,\n  validate,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nimport type { TemplateReplacements } from \"./options.ts\";\nimport type { Metadata, Placeholder } from \"./parse.ts\";\n\nexport default function populatePlaceholders(\n  metadata: Metadata,\n  replacements: TemplateReplacements,\n): t.File {\n  const ast = cloneNode(metadata.ast);\n\n  if (replacements) {\n    metadata.placeholders.forEach(placeholder => {\n      if (!Object.hasOwn(replacements, placeholder.name)) {\n        const placeholderName = placeholder.name;\n\n        throw new Error(\n          `Error: No substitution given for \"${placeholderName}\". If this is not meant to be a\n            placeholder you may want to consider passing one of the following options to @babel/template:\n            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}\n            - { placeholderPattern: /^${placeholderName}$/ }`,\n        );\n      }\n    });\n    Object.keys(replacements).forEach(key => {\n      if (!metadata.placeholderNames.has(key)) {\n        throw new Error(`Unknown substitution \"${key}\" given`);\n      }\n    });\n  }\n\n  // Process in reverse order so AST mutation doesn't change indices that\n  // will be needed for later calls to `placeholder.resolve()`.\n  metadata.placeholders\n    .slice()\n    .reverse()\n    .forEach(placeholder => {\n      try {\n        applyReplacement(\n          placeholder,\n          ast,\n          (replacements && replacements[placeholder.name]) || null,\n        );\n      } catch (e) {\n        e.message = `@babel/template placeholder \"${placeholder.name}\": ${e.message}`;\n        throw e;\n      }\n    });\n\n  return ast;\n}\n\nfunction applyReplacement(\n  placeholder: Placeholder,\n  ast: t.File,\n  replacement: any,\n) {\n  // Track inserted nodes and clone them if they are inserted more than\n  // once to avoid injecting the same node multiple times.\n  if (placeholder.isDuplicate) {\n    if (Array.isArray(replacement)) {\n      replacement = replacement.map(node => cloneNode(node));\n    } else if (typeof replacement === \"object\") {\n      replacement = cloneNode(replacement);\n    }\n  }\n\n  const { parent, key, index } = placeholder.resolve(ast);\n\n  if (placeholder.type === \"string\") {\n    if (typeof replacement === \"string\") {\n      replacement = stringLiteral(replacement);\n    }\n    if (!replacement || !isStringLiteral(replacement)) {\n      throw new Error(\"Expected string substitution\");\n    }\n  } else if (placeholder.type === \"statement\") {\n    if (index === undefined) {\n      if (!replacement) {\n        replacement = emptyStatement();\n      } else if (Array.isArray(replacement)) {\n        replacement = blockStatement(replacement);\n      } else if (typeof replacement === \"string\") {\n        replacement = expressionStatement(identifier(replacement));\n      } else if (!isStatement(replacement)) {\n        replacement = expressionStatement(replacement);\n      }\n    } else {\n      if (replacement && !Array.isArray(replacement)) {\n        if (typeof replacement === \"string\") {\n          replacement = identifier(replacement);\n        }\n        if (!isStatement(replacement)) {\n          replacement = expressionStatement(replacement);\n        }\n      }\n    }\n  } else if (placeholder.type === \"param\") {\n    if (typeof replacement === \"string\") {\n      replacement = identifier(replacement);\n    }\n\n    if (index === undefined) throw new Error(\"Assertion failure.\");\n  } else {\n    if (typeof replacement === \"string\") {\n      replacement = identifier(replacement);\n    }\n    if (Array.isArray(replacement)) {\n      throw new Error(\"Cannot replace single expression with an array.\");\n    }\n  }\n\n  if (index === undefined) {\n    validate(parent, key, replacement);\n\n    (parent as any)[key] = replacement;\n  } else {\n    const items: Array<t.Node> = (parent as any)[key].slice();\n\n    if (placeholder.type === \"statement\" || placeholder.type === \"param\") {\n      if (replacement == null) {\n        items.splice(index, 1);\n      } else if (Array.isArray(replacement)) {\n        items.splice(index, 1, ...replacement);\n      } else {\n        items[index] = replacement;\n      }\n    } else {\n      items[index] = replacement;\n    }\n\n    validate(parent, key, items);\n    (parent as any)[key] = items;\n  }\n}\n","import type { Formatter } from \"./formatters.ts\";\nimport type { TemplateOpts } from \"./options.ts\";\nimport type { Metadata } from \"./parse.ts\";\nimport { normalizeReplacements } from \"./options.ts\";\nimport parseAndBuildMetadata from \"./parse.ts\";\nimport populatePlaceholders from \"./populate.ts\";\n\nexport default function stringTemplate<T>(\n  formatter: Formatter<T>,\n  code: string,\n  opts: TemplateOpts,\n): (arg?: unknown) => T {\n  code = formatter.code(code);\n\n  let metadata: Metadata;\n\n  return (arg?: unknown) => {\n    const replacements = normalizeReplacements(arg);\n\n    if (!metadata) metadata = parseAndBuildMetadata(formatter, code, opts);\n\n    return formatter.unwrap(populatePlaceholders(metadata, replacements));\n  };\n}\n","import type { Formatter } from \"./formatters.ts\";\nimport type { TemplateReplacements, TemplateOpts } from \"./options.ts\";\nimport { normalizeReplacements } from \"./options.ts\";\nimport parseAndBuildMetadata from \"./parse.ts\";\nimport populatePlaceholders from \"./populate.ts\";\n\nexport default function literalTemplate<T>(\n  formatter: Formatter<T>,\n  tpl: Array<string>,\n  opts: TemplateOpts,\n): (_: Array<unknown>) => (_: unknown) => T {\n  const { metadata, names } = buildLiteralData(formatter, tpl, opts);\n\n  return arg => {\n    const defaultReplacements: TemplateReplacements = {};\n    arg.forEach((replacement, i) => {\n      defaultReplacements[names[i]] = replacement;\n    });\n\n    return (arg: unknown) => {\n      const replacements = normalizeReplacements(arg);\n\n      if (replacements) {\n        Object.keys(replacements).forEach(key => {\n          if (Object.hasOwn(defaultReplacements, key)) {\n            throw new Error(\"Unexpected replacement overlap.\");\n          }\n        });\n      }\n\n      return formatter.unwrap(\n        populatePlaceholders(\n          metadata,\n          replacements\n            ? Object.assign(replacements, defaultReplacements)\n            : defaultReplacements,\n        ),\n      );\n    };\n  };\n}\n\nfunction buildLiteralData<T>(\n  formatter: Formatter<T>,\n  tpl: Array<string>,\n  opts: TemplateOpts,\n) {\n  let prefix = \"BABEL_TPL$\";\n\n  const raw = tpl.join(\"\");\n\n  do {\n    // If there are cases where the template already contains $$BABEL_TPL$0 or any other\n    // matching pattern, we keep adding \"$$\" characters until a unique prefix\n    // is found.\n    prefix = \"$$\" + prefix;\n  } while (raw.includes(prefix));\n\n  const { names, code } = buildTemplateCode(tpl, prefix);\n\n  const metadata = parseAndBuildMetadata(formatter, formatter.code(code), {\n    parser: opts.parser,\n\n    // Explicitly include our generated names in the whitelist so users never\n    // have to think about whether their placeholder pattern will match.\n    placeholderWhitelist: new Set(\n      names.concat(\n        opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [],\n      ),\n    ),\n    placeholderPattern: opts.placeholderPattern,\n    preserveComments: opts.preserveComments,\n    syntacticPlaceholders: opts.syntacticPlaceholders,\n  });\n\n  return { metadata, names };\n}\n\nfunction buildTemplateCode(\n  tpl: Array<string>,\n  prefix: string,\n): { names: Array<string>; code: string } {\n  const names = [];\n\n  let code = tpl[0];\n\n  for (let i = 1; i < tpl.length; i++) {\n    const value = `${prefix}${i - 1}`;\n    names.push(value);\n\n    code += value + tpl[i];\n  }\n\n  return { names, code };\n}\n","import { merge, validate } from \"./options.ts\";\nimport type {\n  TemplateOpts,\n  PublicOpts,\n  PublicReplacements,\n} from \"./options.ts\";\nimport type { Formatter } from \"./formatters.ts\";\n\nimport stringTemplate from \"./string.ts\";\nimport literalTemplate from \"./literal.ts\";\n\nexport type TemplateBuilder<T> = {\n  // Build a new builder, merging the given options with the previous ones.\n  (opts: PublicOpts): TemplateBuilder<T>;\n\n  // Building from a string produces an AST builder function by default.\n  (tpl: string, opts?: PublicOpts): (replacements?: PublicReplacements) => T;\n\n  // Building from a template literal produces an AST builder function by default.\n  (\n    tpl: TemplateStringsArray,\n    ...args: Array<unknown>\n  ): (replacements?: PublicReplacements) => T;\n\n  // Allow users to explicitly create templates that produce ASTs, skipping\n  // the need for an intermediate function.\n  ast: {\n    (tpl: string, opts?: PublicOpts): T;\n    (tpl: TemplateStringsArray, ...args: Array<unknown>): T;\n  };\n};\n\n// Prebuild the options that will be used when parsing a `.ast` template.\n// These do not use a pattern because there is no way for users to pass in\n// replacement patterns to begin with, and disabling pattern matching means\n// users have more flexibility in what type of content they have in their\n// template JS.\nconst NO_PLACEHOLDER: TemplateOpts = validate({\n  placeholderPattern: false,\n});\n\nexport default function createTemplateBuilder<T>(\n  formatter: Formatter<T>,\n  defaultOpts?: TemplateOpts,\n): TemplateBuilder<T> {\n  const templateFnCache = new WeakMap();\n  const templateAstCache = new WeakMap();\n  const cachedOpts = defaultOpts || validate(null);\n\n  return Object.assign(\n    ((tpl, ...args) => {\n      if (typeof tpl === \"string\") {\n        if (args.length > 1) throw new Error(\"Unexpected extra params.\");\n        return extendedTrace(\n          stringTemplate(formatter, tpl, merge(cachedOpts, validate(args[0]))),\n        );\n      } else if (Array.isArray(tpl)) {\n        let builder = templateFnCache.get(tpl);\n        if (!builder) {\n          builder = literalTemplate(formatter, tpl, cachedOpts);\n          templateFnCache.set(tpl, builder);\n        }\n        return extendedTrace(builder(args));\n      } else if (typeof tpl === \"object\" && tpl) {\n        if (args.length > 0) throw new Error(\"Unexpected extra params.\");\n        return createTemplateBuilder(\n          formatter,\n          merge(cachedOpts, validate(tpl)),\n        );\n      }\n      throw new Error(`Unexpected template param ${typeof tpl}`);\n    }) as TemplateBuilder<T>,\n    {\n      ast: (tpl: string | Array<string>, ...args: Array<unknown>) => {\n        if (typeof tpl === \"string\") {\n          if (args.length > 1) throw new Error(\"Unexpected extra params.\");\n          return stringTemplate(\n            formatter,\n            tpl,\n            merge(merge(cachedOpts, validate(args[0])), NO_PLACEHOLDER),\n          )();\n        } else if (Array.isArray(tpl)) {\n          let builder = templateAstCache.get(tpl);\n          if (!builder) {\n            builder = literalTemplate(\n              formatter,\n              tpl,\n              merge(cachedOpts, NO_PLACEHOLDER),\n            );\n            templateAstCache.set(tpl, builder);\n          }\n          return builder(args)();\n        }\n\n        throw new Error(`Unexpected template param ${typeof tpl}`);\n      },\n    },\n  );\n}\n\nfunction extendedTrace<Arg, Result>(\n  fn: (_: Arg) => Result,\n): (_: Arg) => Result {\n  // Since we lazy parse the template, we get the current stack so we have the\n  // original stack to append if it errors when parsing\n  let rootStack = \"\";\n  try {\n    // error stack gets populated in IE only on throw\n    // (https://msdn.microsoft.com/en-us/library/hh699850(v=vs.94).aspx)\n    throw new Error();\n  } catch (error) {\n    if (error.stack) {\n      // error.stack does not exists in IE <= 9\n      // We slice off the top 3 items in the stack to remove the call to\n      // 'extendedTrace', and the anonymous builder function, with the final\n      // stripped line being the error message itself since we threw it\n      // in the first place and it doesn't matter.\n      rootStack = error.stack.split(\"\\n\").slice(3).join(\"\\n\");\n    }\n  }\n\n  return (arg: Arg) => {\n    try {\n      return fn(arg);\n    } catch (err) {\n      err.stack += `\\n    =============\\n${rootStack}`;\n      throw err;\n    }\n  };\n}\n","import * as formatters from \"./formatters.ts\";\nimport createTemplateBuilder from \"./builder.ts\";\n\nexport const smart = createTemplateBuilder(formatters.smart);\nexport const statement = createTemplateBuilder(formatters.statement);\nexport const statements = createTemplateBuilder(formatters.statements);\nexport const expression = createTemplateBuilder(formatters.expression);\nexport const program = createTemplateBuilder(formatters.program);\n\ntype DefaultTemplateBuilder = typeof smart & {\n  smart: typeof smart;\n  statement: typeof statement;\n  statements: typeof statements;\n  expression: typeof expression;\n  program: typeof program;\n};\n\nexport default Object.assign(smart.bind(undefined) as DefaultTemplateBuilder, {\n  smart,\n  statement,\n  statements,\n  expression,\n  program,\n  ast: smart.ast,\n});\n\nexport type {\n  PublicOpts as Options,\n  PublicReplacements as Replacements,\n} from \"./options.ts\";\n"],"names":["assertExpressionStatement","_t","makeStatementFormatter","fn","code","str","validate","unwrap","ast","program","body","slice","smart","length","statements","statement","Error","expression","start","stmt","merge","a","b","placeholderWhitelist","placeholderPattern","preserveComments","syntacticPlaceholders","parser","Object","assign","opts","_ref","_objectWithoutPropertiesLoose","_excluded","Set","RegExp","undefined","normalizeReplacements","replacements","Array","isArray","reduce","acc","replacement","i","isCallExpression","isExpressionStatement","isFunction","isIdentifier","isJSXIdentifier","isNewExpression","isPlaceholder","isStatement","isStringLiteral","removePropertiesDeep","traverse","PATTERN","parseAndBuildMetadata","formatter","parseWithCodeFrame","state","syntactic","placeholders","placeholderNames","legacy","placeholderVisitorHandler","node","ancestors","name","hasSyntacticPlaceholders","value","test","has","parent","key","type","expectedNode","push","resolve","resolveAncestors","isDuplicate","add","index","parserOpts","plugins","allowReturnOutsideFunction","allowSuperOutsideMethod","sourceType","parse","err","loc","message","codeFrameColumns","blockStatement","cloneNode","emptyStatement","expressionStatement","identifier","stringLiteral","populatePlaceholders","metadata","forEach","placeholder","hasOwn","placeholderName","keys","reverse","applyReplacement","e","map","items","splice","stringTemplate","arg","literalTemplate","tpl","names","buildLiteralData","defaultReplacements","prefix","raw","join","includes","buildTemplateCode","concat","from","NO_PLACEHOLDER","createTemplateBuilder","defaultOpts","templateFnCache","WeakMap","templateAstCache","cachedOpts","args","extendedTrace","builder","get","set","rootStack","error","stack","split","formatters","bind"],"mappings":"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"}