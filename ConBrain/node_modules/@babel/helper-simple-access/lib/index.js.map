{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import {\n  LOGICAL_OPERATORS,\n  assignmentExpression,\n  binaryExpression,\n  cloneNode,\n  identifier,\n  logicalExpression,\n  numericLiteral,\n  sequenceExpression,\n  unaryExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type { NodePath, Scope, Visitor } from \"@babel/traverse\";\n\ntype State = {\n  scope: Scope;\n  bindingNames: Set<string>;\n  seen: WeakSet<t.Node>;\n};\n\nconst simpleAssignmentVisitor: Visitor<State> = {\n  AssignmentExpression: {\n    exit(path) {\n      const { scope, seen, bindingNames } = this;\n\n      if (path.node.operator === \"=\") return;\n\n      if (seen.has(path.node)) return;\n      seen.add(path.node);\n\n      const left = path.get(\"left\");\n      if (!left.isIdentifier()) return;\n\n      // Simple update-assign foo += 1;\n      // =>   exports.foo =  (foo += 1);\n      const localName = left.node.name;\n\n      if (!bindingNames.has(localName)) return;\n\n      // redeclared in this scope\n      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n        return;\n      }\n\n      const operator = path.node.operator.slice(0, -1);\n      if (LOGICAL_OPERATORS.includes(operator)) {\n        // &&, ||, ??\n        // (foo &&= bar) => (foo && foo = bar)\n        path.replaceWith(\n          logicalExpression(\n            // @ts-expect-error Guarded by LOGICAL_OPERATORS.includes\n            operator,\n            path.node.left,\n            assignmentExpression(\n              \"=\",\n              cloneNode(path.node.left),\n              path.node.right,\n            ),\n          ),\n        );\n      } else {\n        // (foo += bar) => (foo = foo + bar)\n        path.node.right = binaryExpression(\n          // @ts-expect-error An assignment expression operator removing \"=\" must\n          // be a valid binary operator\n          operator,\n          cloneNode(path.node.left),\n          path.node.right,\n        );\n        path.node.operator = \"=\";\n      }\n    },\n  },\n};\n\nif (!process.env.BABEL_8_BREAKING) {\n  simpleAssignmentVisitor.UpdateExpression = {\n    exit(path) {\n      // @ts-expect-error This is Babel7-only\n      if (!this.includeUpdateExpression) return;\n\n      const { scope, bindingNames } = this;\n\n      const arg = path.get(\"argument\");\n      if (!arg.isIdentifier()) return;\n      const localName = arg.node.name;\n\n      if (!bindingNames.has(localName)) return;\n\n      // redeclared in this scope\n      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n        return;\n      }\n\n      if (\n        path.parentPath.isExpressionStatement() &&\n        !path.isCompletionRecord()\n      ) {\n        // ++i => (i += 1);\n        const operator = path.node.operator == \"++\" ? \"+=\" : \"-=\";\n        path.replaceWith(\n          assignmentExpression(operator, arg.node, numericLiteral(1)),\n        );\n      } else if (path.node.prefix) {\n        // ++i => (i = (+i) + 1);\n        path.replaceWith(\n          assignmentExpression(\n            \"=\",\n            identifier(localName),\n            binaryExpression(\n              path.node.operator[0] as \"+\" | \"-\",\n              unaryExpression(\"+\", arg.node),\n              numericLiteral(1),\n            ),\n          ),\n        );\n      } else {\n        const old = path.scope.generateUidIdentifierBasedOnNode(\n          arg.node,\n          \"old\",\n        );\n        const varName = old.name;\n        path.scope.push({ id: old });\n\n        const binary = binaryExpression(\n          path.node.operator[0] as \"+\" | \"-\",\n          identifier(varName),\n          // todo: support bigint\n          numericLiteral(1),\n        );\n\n        // i++ => (_old = (+i), i = _old + 1, _old)\n        path.replaceWith(\n          sequenceExpression([\n            assignmentExpression(\n              \"=\",\n              identifier(varName),\n              unaryExpression(\"+\", arg.node),\n            ),\n            assignmentExpression(\"=\", cloneNode(arg.node), binary),\n            identifier(varName),\n          ]),\n        );\n      }\n    },\n  };\n}\n\nexport default function simplifyAccess(\n  path: NodePath,\n  bindingNames: Set<string>,\n) {\n  if (process.env.BABEL_8_BREAKING) {\n    path.traverse(simpleAssignmentVisitor, {\n      scope: path.scope,\n      bindingNames,\n      seen: new WeakSet(),\n    });\n  } else {\n    path.traverse(simpleAssignmentVisitor, {\n      scope: path.scope,\n      bindingNames,\n      seen: new WeakSet(),\n      // @ts-expect-error This is Babel7-only\n      includeUpdateExpression: arguments[2] ?? true,\n    });\n  }\n}\n"],"names":["LOGICAL_OPERATORS","assignmentExpression","binaryExpression","cloneNode","identifier","logicalExpression","numericLiteral","sequenceExpression","unaryExpression","_t","simpleAssignmentVisitor","AssignmentExpression","exit","path","scope","seen","bindingNames","node","operator","has","add","left","get","isIdentifier","localName","name","getBinding","slice","includes","replaceWith","right","simplifyAccess","traverse","WeakSet"],"mappings":";;AAUsB,MAAA;EATpBA,iBAAiB;EACjBC,oBAAoB;EACpBC,gBAAgB;EAChBC,SAAS;EACTC,UAAU;EACVC,iBAAiB;EACjBC,cAAc;EACdC,kBAAkB;AAClBC,EAAAA,eAAAA;AAAe,CAAA,GAAAC,EAAA,CAAA;AAWjB,MAAMC,uBAAuC,GAAG;AAC9CC,EAAAA,oBAAoB,EAAE;IACpBC,IAAIA,CAACC,IAAI,EAAE;MACT,MAAM;QAAEC,KAAK;QAAEC,IAAI;AAAEC,QAAAA,YAAAA;AAAa,OAAC,GAAG,IAAI,CAAA;AAE1C,MAAA,IAAIH,IAAI,CAACI,IAAI,CAACC,QAAQ,KAAK,GAAG,EAAE,OAAA;MAEhC,IAAIH,IAAI,CAACI,GAAG,CAACN,IAAI,CAACI,IAAI,CAAC,EAAE,OAAA;AACzBF,MAAAA,IAAI,CAACK,GAAG,CAACP,IAAI,CAACI,IAAI,CAAC,CAAA;AAEnB,MAAA,MAAMI,IAAI,GAAGR,IAAI,CAACS,GAAG,CAAC,MAAM,CAAC,CAAA;AAC7B,MAAA,IAAI,CAACD,IAAI,CAACE,YAAY,EAAE,EAAE,OAAA;AAI1B,MAAA,MAAMC,SAAS,GAAGH,IAAI,CAACJ,IAAI,CAACQ,IAAI,CAAA;AAEhC,MAAA,IAAI,CAACT,YAAY,CAACG,GAAG,CAACK,SAAS,CAAC,EAAE,OAAA;AAGlC,MAAA,IAAIV,KAAK,CAACY,UAAU,CAACF,SAAS,CAAC,KAAKX,IAAI,CAACC,KAAK,CAACY,UAAU,CAACF,SAAS,CAAC,EAAE;AACpE,QAAA,OAAA;AACF,OAAA;AAEA,MAAA,MAAMN,QAAQ,GAAGL,IAAI,CAACI,IAAI,CAACC,QAAQ,CAACS,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAA;AAChD,MAAA,IAAI3B,iBAAiB,CAAC4B,QAAQ,CAACV,QAAQ,CAAC,EAAE;AAGxCL,QAAAA,IAAI,CAACgB,WAAW,CACdxB,iBAAiB,CAEfa,QAAQ,EACRL,IAAI,CAACI,IAAI,CAACI,IAAI,EACdpB,oBAAoB,CAClB,GAAG,EACHE,SAAS,CAACU,IAAI,CAACI,IAAI,CAACI,IAAI,CAAC,EACzBR,IAAI,CAACI,IAAI,CAACa,KACZ,CACF,CACF,CAAC,CAAA;AACH,OAAC,MAAM;QAELjB,IAAI,CAACI,IAAI,CAACa,KAAK,GAAG5B,gBAAgB,CAGhCgB,QAAQ,EACRf,SAAS,CAACU,IAAI,CAACI,IAAI,CAACI,IAAI,CAAC,EACzBR,IAAI,CAACI,IAAI,CAACa,KACZ,CAAC,CAAA;AACDjB,QAAAA,IAAI,CAACI,IAAI,CAACC,QAAQ,GAAG,GAAG,CAAA;AAC1B,OAAA;AACF,KAAA;AACF,GAAA;AACF,CAAC,CAAA;AA2Ec,SAASa,cAAcA,CACpClB,IAAc,EACdG,YAAyB,EACzB;AACkC,EAAA;AAChCH,IAAAA,IAAI,CAACmB,QAAQ,CAACtB,uBAAuB,EAAE;MACrCI,KAAK,EAAED,IAAI,CAACC,KAAK;MACjBE,YAAY;MACZD,IAAI,EAAE,IAAIkB,OAAO,EAAC;AACpB,KAAC,CAAC,CAAA;AACJ,GAAA;AASF;;;;"}